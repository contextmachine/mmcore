# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
    query: query_root
    mutation: mutation_root
    subscription: subscription_root
}

"whether this query should be cached (Hasura Cloud only)"
directive @cached(
    "refresh the cache entry"
    refresh: Boolean! = false,
    "measured in seconds"
    ttl: Int! = 60
) on QUERY

"attractive"
type buffgeom_attributes {
    index(
        "JSON select path"
        path: String
    ): jsonb
    normal(
        "JSON select path"
        path: String
    ): jsonb
    position(
        "JSON select path"
        path: String
    ): jsonb
    type: String!
    uuid: uuid!
    uv(
        "JSON select path"
        path: String
    ): jsonb
}

"aggregated selection of \"buffgeom.attributes\""
type buffgeom_attributes_aggregate {
    aggregate: buffgeom_attributes_aggregate_fields
    nodes: [buffgeom_attributes!]!
}

"aggregate fields of \"buffgeom.attributes\""
type buffgeom_attributes_aggregate_fields {
    count(columns: [buffgeom_attributes_select_column!], distinct: Boolean): Int!
    max: buffgeom_attributes_max_fields
    min: buffgeom_attributes_min_fields
}

"aggregate max on columns"
type buffgeom_attributes_max_fields {
    type: String
    uuid: uuid
}

"aggregate min on columns"
type buffgeom_attributes_min_fields {
    type: String
    uuid: uuid
}

"response of any mutation on the table \"buffgeom.attributes\""
type buffgeom_attributes_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [buffgeom_attributes!]!
}

"geometry fields"
type buffgeom_objects {
    castShadow: Boolean!
    children(
        "JSON select path"
        path: String
    ): jsonb
    geometry: uuid!
    layers: Int!
    material: uuid!
    matrix(
        "JSON select path"
        path: String
    ): jsonb!
    name: String
    receiveShadow: Boolean!
    type: String!
    userData(
        "JSON select path"
        path: String
    ): jsonb
    uuid: uuid!
}

"aggregated selection of \"buffgeom.objects\""
type buffgeom_objects_aggregate {
    aggregate: buffgeom_objects_aggregate_fields
    nodes: [buffgeom_objects!]!
}

"aggregate fields of \"buffgeom.objects\""
type buffgeom_objects_aggregate_fields {
    avg: buffgeom_objects_avg_fields
    count(columns: [buffgeom_objects_select_column!], distinct: Boolean): Int!
    max: buffgeom_objects_max_fields
    min: buffgeom_objects_min_fields
    stddev: buffgeom_objects_stddev_fields
    stddev_pop: buffgeom_objects_stddev_pop_fields
    stddev_samp: buffgeom_objects_stddev_samp_fields
    sum: buffgeom_objects_sum_fields
    var_pop: buffgeom_objects_var_pop_fields
    var_samp: buffgeom_objects_var_samp_fields
    variance: buffgeom_objects_variance_fields
}

"aggregate avg on columns"
type buffgeom_objects_avg_fields {
    layers: Float
}

"aggregate max on columns"
type buffgeom_objects_max_fields {
    geometry: uuid
    layers: Int
    material: uuid
    name: String
    type: String
    uuid: uuid
}

"aggregate min on columns"
type buffgeom_objects_min_fields {
    geometry: uuid
    layers: Int
    material: uuid
    name: String
    type: String
    uuid: uuid
}

"response of any mutation on the table \"buffgeom.objects\""
type buffgeom_objects_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [buffgeom_objects!]!
}

"aggregate stddev on columns"
type buffgeom_objects_stddev_fields {
    layers: Float
}

"aggregate stddev_pop on columns"
type buffgeom_objects_stddev_pop_fields {
    layers: Float
}

"aggregate stddev_samp on columns"
type buffgeom_objects_stddev_samp_fields {
    layers: Float
}

"aggregate sum on columns"
type buffgeom_objects_sum_fields {
    layers: Int
}

"aggregate var_pop on columns"
type buffgeom_objects_var_pop_fields {
    layers: Float
}

"aggregate var_samp on columns"
type buffgeom_objects_var_samp_fields {
    layers: Float
}

"aggregate variance on columns"
type buffgeom_objects_variance_fields {
    layers: Float
}

"mutation root"
type mutation_root {
    "delete data from the table: \"buffgeom.attributes\""
    delete_buffgeom_attributes(
        "filter the rows which have to be deleted"
        where: buffgeom_attributes_bool_exp!
    ): buffgeom_attributes_mutation_response
    "delete single row from the table: \"buffgeom.attributes\""
    delete_buffgeom_attributes_by_pk(uuid: uuid!): buffgeom_attributes
    "delete data from the table: \"buffgeom.objects\""
    delete_buffgeom_objects(
        "filter the rows which have to be deleted"
        where: buffgeom_objects_bool_exp!
    ): buffgeom_objects_mutation_response
    "delete single row from the table: \"buffgeom.objects\""
    delete_buffgeom_objects_by_pk(uuid: uuid!): buffgeom_objects
    "delete data from the table: \"projects.projects_hub\""
    delete_projects_projects_hub(
        "filter the rows which have to be deleted"
        where: projects_projects_hub_bool_exp!
    ): projects_projects_hub_mutation_response
    "delete single row from the table: \"projects.projects_hub\""
    delete_projects_projects_hub_by_pk(id: uuid!): projects_projects_hub
    "delete data from the table: \"projects.queries_hub\""
    delete_projects_queries_hub(
        "filter the rows which have to be deleted"
        where: projects_queries_hub_bool_exp!
    ): projects_queries_hub_mutation_response
    "delete single row from the table: \"projects.queries_hub\""
    delete_projects_queries_hub_by_pk(id: uuid!): projects_queries_hub
    "insert data into the table: \"buffgeom.attributes\""
    insert_buffgeom_attributes(
        "the rows to be inserted"
        objects: [buffgeom_attributes_insert_input!]!,
        "upsert condition"
        on_conflict: buffgeom_attributes_on_conflict
    ): buffgeom_attributes_mutation_response
    "insert a single row into the table: \"buffgeom.attributes\""
    insert_buffgeom_attributes_one(
        "the row to be inserted"
        object: buffgeom_attributes_insert_input!,
        "upsert condition"
        on_conflict: buffgeom_attributes_on_conflict
    ): buffgeom_attributes
    "insert data into the table: \"buffgeom.objects\""
    insert_buffgeom_objects(
        "the rows to be inserted"
        objects: [buffgeom_objects_insert_input!]!,
        "upsert condition"
        on_conflict: buffgeom_objects_on_conflict
    ): buffgeom_objects_mutation_response
    "insert a single row into the table: \"buffgeom.objects\""
    insert_buffgeom_objects_one(
        "the row to be inserted"
        object: buffgeom_objects_insert_input!,
        "upsert condition"
        on_conflict: buffgeom_objects_on_conflict
    ): buffgeom_objects
    "insert data into the table: \"projects.projects_hub\""
    insert_projects_projects_hub(
        "the rows to be inserted"
        objects: [projects_projects_hub_insert_input!]!,
        "upsert condition"
        on_conflict: projects_projects_hub_on_conflict
    ): projects_projects_hub_mutation_response
    "insert a single row into the table: \"projects.projects_hub\""
    insert_projects_projects_hub_one(
        "the row to be inserted"
        object: projects_projects_hub_insert_input!,
        "upsert condition"
        on_conflict: projects_projects_hub_on_conflict
    ): projects_projects_hub
    "insert data into the table: \"projects.queries_hub\""
    insert_projects_queries_hub(
        "the rows to be inserted"
        objects: [projects_queries_hub_insert_input!]!,
        "upsert condition"
        on_conflict: projects_queries_hub_on_conflict
    ): projects_queries_hub_mutation_response
    "insert a single row into the table: \"projects.queries_hub\""
    insert_projects_queries_hub_one(
        "the row to be inserted"
        object: projects_queries_hub_insert_input!,
        "upsert condition"
        on_conflict: projects_queries_hub_on_conflict
    ): projects_queries_hub
    "update data of the table: \"buffgeom.attributes\""
    update_buffgeom_attributes(
        "append existing jsonb value of filtered columns with new jsonb value"
        _append: buffgeom_attributes_append_input,
        "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
        _delete_at_path: buffgeom_attributes_delete_at_path_input,
        "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
        _delete_elem: buffgeom_attributes_delete_elem_input,
        "delete key/value pair or string element. key/value pairs are matched based on their key value"
        _delete_key: buffgeom_attributes_delete_key_input,
        "prepend existing jsonb value of filtered columns with new jsonb value"
        _prepend: buffgeom_attributes_prepend_input,
        "sets the columns of the filtered rows to the given values"
        _set: buffgeom_attributes_set_input,
        "filter the rows which have to be updated"
        where: buffgeom_attributes_bool_exp!
    ): buffgeom_attributes_mutation_response
    "update single row of the table: \"buffgeom.attributes\""
    update_buffgeom_attributes_by_pk(
        "append existing jsonb value of filtered columns with new jsonb value"
        _append: buffgeom_attributes_append_input,
        "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
        _delete_at_path: buffgeom_attributes_delete_at_path_input,
        "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
        _delete_elem: buffgeom_attributes_delete_elem_input,
        "delete key/value pair or string element. key/value pairs are matched based on their key value"
        _delete_key: buffgeom_attributes_delete_key_input,
        "prepend existing jsonb value of filtered columns with new jsonb value"
        _prepend: buffgeom_attributes_prepend_input,
        "sets the columns of the filtered rows to the given values"
        _set: buffgeom_attributes_set_input,
        pk_columns: buffgeom_attributes_pk_columns_input!
    ): buffgeom_attributes
    "update multiples rows of table: \"buffgeom.attributes\""
    update_buffgeom_attributes_many(
        "updates to execute, in order"
        updates: [buffgeom_attributes_updates!]!
    ): [buffgeom_attributes_mutation_response]
    "update data of the table: \"buffgeom.objects\""
    update_buffgeom_objects(
        "append existing jsonb value of filtered columns with new jsonb value"
        _append: buffgeom_objects_append_input,
        "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
        _delete_at_path: buffgeom_objects_delete_at_path_input,
        "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
        _delete_elem: buffgeom_objects_delete_elem_input,
        "delete key/value pair or string element. key/value pairs are matched based on their key value"
        _delete_key: buffgeom_objects_delete_key_input,
        "increments the numeric columns with given value of the filtered values"
        _inc: buffgeom_objects_inc_input,
        "prepend existing jsonb value of filtered columns with new jsonb value"
        _prepend: buffgeom_objects_prepend_input,
        "sets the columns of the filtered rows to the given values"
        _set: buffgeom_objects_set_input,
        "filter the rows which have to be updated"
        where: buffgeom_objects_bool_exp!
    ): buffgeom_objects_mutation_response
    "update single row of the table: \"buffgeom.objects\""
    update_buffgeom_objects_by_pk(
        "append existing jsonb value of filtered columns with new jsonb value"
        _append: buffgeom_objects_append_input,
        "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
        _delete_at_path: buffgeom_objects_delete_at_path_input,
        "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
        _delete_elem: buffgeom_objects_delete_elem_input,
        "delete key/value pair or string element. key/value pairs are matched based on their key value"
        _delete_key: buffgeom_objects_delete_key_input,
        "increments the numeric columns with given value of the filtered values"
        _inc: buffgeom_objects_inc_input,
        "prepend existing jsonb value of filtered columns with new jsonb value"
        _prepend: buffgeom_objects_prepend_input,
        "sets the columns of the filtered rows to the given values"
        _set: buffgeom_objects_set_input,
        pk_columns: buffgeom_objects_pk_columns_input!
    ): buffgeom_objects
    "update multiples rows of table: \"buffgeom.objects\""
    update_buffgeom_objects_many(
        "updates to execute, in order"
        updates: [buffgeom_objects_updates!]!
    ): [buffgeom_objects_mutation_response]
    "update data of the table: \"projects.projects_hub\""
    update_projects_projects_hub(
        "sets the columns of the filtered rows to the given values"
        _set: projects_projects_hub_set_input,
        "filter the rows which have to be updated"
        where: projects_projects_hub_bool_exp!
    ): projects_projects_hub_mutation_response
    "update single row of the table: \"projects.projects_hub\""
    update_projects_projects_hub_by_pk(
        "sets the columns of the filtered rows to the given values"
        _set: projects_projects_hub_set_input,
        pk_columns: projects_projects_hub_pk_columns_input!
    ): projects_projects_hub
    "update multiples rows of table: \"projects.projects_hub\""
    update_projects_projects_hub_many(
        "updates to execute, in order"
        updates: [projects_projects_hub_updates!]!
    ): [projects_projects_hub_mutation_response]
    "update data of the table: \"projects.queries_hub\""
    update_projects_queries_hub(
        "append existing jsonb value of filtered columns with new jsonb value"
        _append: projects_queries_hub_append_input,
        "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
        _delete_at_path: projects_queries_hub_delete_at_path_input,
        "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
        _delete_elem: projects_queries_hub_delete_elem_input,
        "delete key/value pair or string element. key/value pairs are matched based on their key value"
        _delete_key: projects_queries_hub_delete_key_input,
        "prepend existing jsonb value of filtered columns with new jsonb value"
        _prepend: projects_queries_hub_prepend_input,
        "sets the columns of the filtered rows to the given values"
        _set: projects_queries_hub_set_input,
        "filter the rows which have to be updated"
        where: projects_queries_hub_bool_exp!
    ): projects_queries_hub_mutation_response
    "update single row of the table: \"projects.queries_hub\""
    update_projects_queries_hub_by_pk(
        "append existing jsonb value of filtered columns with new jsonb value"
        _append: projects_queries_hub_append_input,
        "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
        _delete_at_path: projects_queries_hub_delete_at_path_input,
        "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
        _delete_elem: projects_queries_hub_delete_elem_input,
        "delete key/value pair or string element. key/value pairs are matched based on their key value"
        _delete_key: projects_queries_hub_delete_key_input,
        "prepend existing jsonb value of filtered columns with new jsonb value"
        _prepend: projects_queries_hub_prepend_input,
        "sets the columns of the filtered rows to the given values"
        _set: projects_queries_hub_set_input,
        pk_columns: projects_queries_hub_pk_columns_input!
    ): projects_queries_hub
    "update multiples rows of table: \"projects.queries_hub\""
    update_projects_queries_hub_many(
        "updates to execute, in order"
        updates: [projects_queries_hub_updates!]!
    ): [projects_queries_hub_mutation_response]
}

"columns and relationships of \"projects.projects_hub\""
type projects_projects_hub {
    id: uuid!
    last_visited: timestamptz
    name: String
    thumb: String
}

"aggregated selection of \"projects.projects_hub\""
type projects_projects_hub_aggregate {
    aggregate: projects_projects_hub_aggregate_fields
    nodes: [projects_projects_hub!]!
}

"aggregate fields of \"projects.projects_hub\""
type projects_projects_hub_aggregate_fields {
    count(columns: [projects_projects_hub_select_column!], distinct: Boolean): Int!
    max: projects_projects_hub_max_fields
    min: projects_projects_hub_min_fields
}

"aggregate max on columns"
type projects_projects_hub_max_fields {
    id: uuid
    last_visited: timestamptz
    name: String
    thumb: String
}

"aggregate min on columns"
type projects_projects_hub_min_fields {
    id: uuid
    last_visited: timestamptz
    name: String
    thumb: String
}

"response of any mutation on the table \"projects.projects_hub\""
type projects_projects_hub_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [projects_projects_hub!]!
}

"columns and relationships of \"projects.queries_hub\""
type projects_queries_hub {
    body(
        "JSON select path"
        path: String
    ): jsonb!
    endpoint: String!
    id: uuid!
    name: String!
    project_name: String
    tags(
        "JSON select path"
        path: String
    ): jsonb!
}

"aggregated selection of \"projects.queries_hub\""
type projects_queries_hub_aggregate {
    aggregate: projects_queries_hub_aggregate_fields
    nodes: [projects_queries_hub!]!
}

"aggregate fields of \"projects.queries_hub\""
type projects_queries_hub_aggregate_fields {
    count(columns: [projects_queries_hub_select_column!], distinct: Boolean): Int!
    max: projects_queries_hub_max_fields
    min: projects_queries_hub_min_fields
}

"aggregate max on columns"
type projects_queries_hub_max_fields {
    endpoint: String
    id: uuid
    name: String
    project_name: String
}

"aggregate min on columns"
type projects_queries_hub_min_fields {
    endpoint: String
    id: uuid
    name: String
    project_name: String
}

"response of any mutation on the table \"projects.queries_hub\""
type projects_queries_hub_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [projects_queries_hub!]!
}

type query_root {
    "fetch data from the table: \"buffgeom.attributes\""
    buffgeom_attributes(
        "distinct select on columns"
        distinct_on: [buffgeom_attributes_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [buffgeom_attributes_order_by!],
        "filter the rows returned"
        where: buffgeom_attributes_bool_exp
    ): [buffgeom_attributes!]!
    "fetch aggregated fields from the table: \"buffgeom.attributes\""
    buffgeom_attributes_aggregate(
        "distinct select on columns"
        distinct_on: [buffgeom_attributes_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [buffgeom_attributes_order_by!],
        "filter the rows returned"
        where: buffgeom_attributes_bool_exp
    ): buffgeom_attributes_aggregate!
    "fetch data from the table: \"buffgeom.attributes\" using primary key columns"
    buffgeom_attributes_by_pk(uuid: uuid!): buffgeom_attributes
    "fetch data from the table: \"buffgeom.objects\""
    buffgeom_objects(
        "distinct select on columns"
        distinct_on: [buffgeom_objects_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [buffgeom_objects_order_by!],
        "filter the rows returned"
        where: buffgeom_objects_bool_exp
    ): [buffgeom_objects!]!
    "fetch aggregated fields from the table: \"buffgeom.objects\""
    buffgeom_objects_aggregate(
        "distinct select on columns"
        distinct_on: [buffgeom_objects_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [buffgeom_objects_order_by!],
        "filter the rows returned"
        where: buffgeom_objects_bool_exp
    ): buffgeom_objects_aggregate!
    "fetch data from the table: \"buffgeom.objects\" using primary key columns"
    buffgeom_objects_by_pk(uuid: uuid!): buffgeom_objects
    "fetch data from the table: \"projects.projects_hub\""
    projects_projects_hub(
        "distinct select on columns"
        distinct_on: [projects_projects_hub_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [projects_projects_hub_order_by!],
        "filter the rows returned"
        where: projects_projects_hub_bool_exp
    ): [projects_projects_hub!]!
    "fetch aggregated fields from the table: \"projects.projects_hub\""
    projects_projects_hub_aggregate(
        "distinct select on columns"
        distinct_on: [projects_projects_hub_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [projects_projects_hub_order_by!],
        "filter the rows returned"
        where: projects_projects_hub_bool_exp
    ): projects_projects_hub_aggregate!
    "fetch data from the table: \"projects.projects_hub\" using primary key columns"
    projects_projects_hub_by_pk(id: uuid!): projects_projects_hub
    "fetch data from the table: \"projects.queries_hub\""
    projects_queries_hub(
        "distinct select on columns"
        distinct_on: [projects_queries_hub_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [projects_queries_hub_order_by!],
        "filter the rows returned"
        where: projects_queries_hub_bool_exp
    ): [projects_queries_hub!]!
    "fetch aggregated fields from the table: \"projects.queries_hub\""
    projects_queries_hub_aggregate(
        "distinct select on columns"
        distinct_on: [projects_queries_hub_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [projects_queries_hub_order_by!],
        "filter the rows returned"
        where: projects_queries_hub_bool_exp
    ): projects_queries_hub_aggregate!
    "fetch data from the table: \"projects.queries_hub\" using primary key columns"
    projects_queries_hub_by_pk(id: uuid!): projects_queries_hub
}

type subscription_root {
    "fetch data from the table: \"buffgeom.attributes\""
    buffgeom_attributes(
        "distinct select on columns"
        distinct_on: [buffgeom_attributes_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [buffgeom_attributes_order_by!],
        "filter the rows returned"
        where: buffgeom_attributes_bool_exp
    ): [buffgeom_attributes!]!
    "fetch aggregated fields from the table: \"buffgeom.attributes\""
    buffgeom_attributes_aggregate(
        "distinct select on columns"
        distinct_on: [buffgeom_attributes_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [buffgeom_attributes_order_by!],
        "filter the rows returned"
        where: buffgeom_attributes_bool_exp
    ): buffgeom_attributes_aggregate!
    "fetch data from the table: \"buffgeom.attributes\" using primary key columns"
    buffgeom_attributes_by_pk(uuid: uuid!): buffgeom_attributes
    "fetch data from the table in a streaming manner: \"buffgeom.attributes\""
    buffgeom_attributes_stream(
        "maximum number of rows returned in a single batch"
        batch_size: Int!,
        "cursor to stream the results returned by the query"
        cursor: [buffgeom_attributes_stream_cursor_input]!,
        "filter the rows returned"
        where: buffgeom_attributes_bool_exp
    ): [buffgeom_attributes!]!
    "fetch data from the table: \"buffgeom.objects\""
    buffgeom_objects(
        "distinct select on columns"
        distinct_on: [buffgeom_objects_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [buffgeom_objects_order_by!],
        "filter the rows returned"
        where: buffgeom_objects_bool_exp
    ): [buffgeom_objects!]!
    "fetch aggregated fields from the table: \"buffgeom.objects\""
    buffgeom_objects_aggregate(
        "distinct select on columns"
        distinct_on: [buffgeom_objects_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [buffgeom_objects_order_by!],
        "filter the rows returned"
        where: buffgeom_objects_bool_exp
    ): buffgeom_objects_aggregate!
    "fetch data from the table: \"buffgeom.objects\" using primary key columns"
    buffgeom_objects_by_pk(uuid: uuid!): buffgeom_objects
    "fetch data from the table in a streaming manner: \"buffgeom.objects\""
    buffgeom_objects_stream(
        "maximum number of rows returned in a single batch"
        batch_size: Int!,
        "cursor to stream the results returned by the query"
        cursor: [buffgeom_objects_stream_cursor_input]!,
        "filter the rows returned"
        where: buffgeom_objects_bool_exp
    ): [buffgeom_objects!]!
    "fetch data from the table: \"projects.projects_hub\""
    projects_projects_hub(
        "distinct select on columns"
        distinct_on: [projects_projects_hub_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [projects_projects_hub_order_by!],
        "filter the rows returned"
        where: projects_projects_hub_bool_exp
    ): [projects_projects_hub!]!
    "fetch aggregated fields from the table: \"projects.projects_hub\""
    projects_projects_hub_aggregate(
        "distinct select on columns"
        distinct_on: [projects_projects_hub_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [projects_projects_hub_order_by!],
        "filter the rows returned"
        where: projects_projects_hub_bool_exp
    ): projects_projects_hub_aggregate!
    "fetch data from the table: \"projects.projects_hub\" using primary key columns"
    projects_projects_hub_by_pk(id: uuid!): projects_projects_hub
    "fetch data from the table in a streaming manner: \"projects.projects_hub\""
    projects_projects_hub_stream(
        "maximum number of rows returned in a single batch"
        batch_size: Int!,
        "cursor to stream the results returned by the query"
        cursor: [projects_projects_hub_stream_cursor_input]!,
        "filter the rows returned"
        where: projects_projects_hub_bool_exp
    ): [projects_projects_hub!]!
    "fetch data from the table: \"projects.queries_hub\""
    projects_queries_hub(
        "distinct select on columns"
        distinct_on: [projects_queries_hub_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [projects_queries_hub_order_by!],
        "filter the rows returned"
        where: projects_queries_hub_bool_exp
    ): [projects_queries_hub!]!
    "fetch aggregated fields from the table: \"projects.queries_hub\""
    projects_queries_hub_aggregate(
        "distinct select on columns"
        distinct_on: [projects_queries_hub_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [projects_queries_hub_order_by!],
        "filter the rows returned"
        where: projects_queries_hub_bool_exp
    ): projects_queries_hub_aggregate!
    "fetch data from the table: \"projects.queries_hub\" using primary key columns"
    projects_queries_hub_by_pk(id: uuid!): projects_queries_hub
    "fetch data from the table in a streaming manner: \"projects.queries_hub\""
    projects_queries_hub_stream(
        "maximum number of rows returned in a single batch"
        batch_size: Int!,
        "cursor to stream the results returned by the query"
        cursor: [projects_queries_hub_stream_cursor_input]!,
        "filter the rows returned"
        where: projects_queries_hub_bool_exp
    ): [projects_queries_hub!]!
}

"unique or primary key constraints on table \"buffgeom.attributes\""
enum buffgeom_attributes_constraint {
    "unique or primary key constraint on columns \"uuid\""
    attributes_pkey
    "unique or primary key constraint on columns \"uuid\""
    attributes_uuid_key
}

"select columns of table \"buffgeom.attributes\""
enum buffgeom_attributes_select_column {
    "column name"
    index
    "column name"
    normal
    "column name"
    position
    "column name"
    type
    "column name"
    uuid
    "column name"
    uv
}

"update columns of table \"buffgeom.attributes\""
enum buffgeom_attributes_update_column {
    "column name"
    index
    "column name"
    normal
    "column name"
    position
    "column name"
    type
    "column name"
    uuid
    "column name"
    uv
}

"unique or primary key constraints on table \"buffgeom.objects\""
enum buffgeom_objects_constraint {
    "unique or primary key constraint on columns \"uuid\""
    objects_pkey
}

"select columns of table \"buffgeom.objects\""
enum buffgeom_objects_select_column {
    "column name"
    castShadow
    "column name"
    children
    "column name"
    geometry
    "column name"
    layers
    "column name"
    material
    "column name"
    matrix
    "column name"
    name
    "column name"
    receiveShadow
    "column name"
    type
    "column name"
    userData
    "column name"
    uuid
}

"update columns of table \"buffgeom.objects\""
enum buffgeom_objects_update_column {
    "column name"
    castShadow
    "column name"
    children
    "column name"
    geometry
    "column name"
    layers
    "column name"
    material
    "column name"
    matrix
    "column name"
    name
    "column name"
    receiveShadow
    "column name"
    type
    "column name"
    userData
    "column name"
    uuid
}

"ordering argument of a cursor"
enum cursor_ordering {
    "ascending ordering of the cursor"
    ASC
    "descending ordering of the cursor"
    DESC
}

"column ordering options"
enum order_by {
    "in ascending order, nulls last"
    asc
    "in ascending order, nulls first"
    asc_nulls_first
    "in ascending order, nulls last"
    asc_nulls_last
    "in descending order, nulls first"
    desc
    "in descending order, nulls first"
    desc_nulls_first
    "in descending order, nulls last"
    desc_nulls_last
}

"unique or primary key constraints on table \"projects.projects_hub\""
enum projects_projects_hub_constraint {
    "unique or primary key constraint on columns \"id\""
    projects_hub_pkey
}

"select columns of table \"projects.projects_hub\""
enum projects_projects_hub_select_column {
    "column name"
    id
    "column name"
    last_visited
    "column name"
    name
    "column name"
    thumb
}

"update columns of table \"projects.projects_hub\""
enum projects_projects_hub_update_column {
    "column name"
    id
    "column name"
    last_visited
    "column name"
    name
    "column name"
    thumb
}

"unique or primary key constraints on table \"projects.queries_hub\""
enum projects_queries_hub_constraint {
    "unique or primary key constraint on columns \"id\""
    queries_hub_pkey
}

"select columns of table \"projects.queries_hub\""
enum projects_queries_hub_select_column {
    "column name"
    body
    "column name"
    endpoint
    "column name"
    id
    "column name"
    name
    "column name"
    project_name
    "column name"
    tags
}

"update columns of table \"projects.queries_hub\""
enum projects_queries_hub_update_column {
    "column name"
    body
    "column name"
    endpoint
    "column name"
    id
    "column name"
    name
    "column name"
    project_name
    "column name"
    tags
}

scalar jsonb

scalar timestamptz

scalar uuid

"Boolean expression to compare columns of type \"Boolean\". All fields are combined with logical 'AND'."
input Boolean_comparison_exp {
    _eq: Boolean
    _gt: Boolean
    _gte: Boolean
    _in: [Boolean!]
    _is_null: Boolean
    _lt: Boolean
    _lte: Boolean
    _neq: Boolean
    _nin: [Boolean!]
}

"Boolean expression to compare columns of type \"Int\". All fields are combined with logical 'AND'."
input Int_comparison_exp {
    _eq: Int
    _gt: Int
    _gte: Int
    _in: [Int!]
    _is_null: Boolean
    _lt: Int
    _lte: Int
    _neq: Int
    _nin: [Int!]
}

"Boolean expression to compare columns of type \"String\". All fields are combined with logical 'AND'."
input String_comparison_exp {
    _eq: String
    _gt: String
    _gte: String
    "does the column match the given case-insensitive pattern"
    _ilike: String
    _in: [String!]
    "does the column match the given POSIX regular expression, case insensitive"
    _iregex: String
    _is_null: Boolean
    "does the column match the given pattern"
    _like: String
    _lt: String
    _lte: String
    _neq: String
    "does the column NOT match the given case-insensitive pattern"
    _nilike: String
    _nin: [String!]
    "does the column NOT match the given POSIX regular expression, case insensitive"
    _niregex: String
    "does the column NOT match the given pattern"
    _nlike: String
    "does the column NOT match the given POSIX regular expression, case sensitive"
    _nregex: String
    "does the column NOT match the given SQL regular expression"
    _nsimilar: String
    "does the column match the given POSIX regular expression, case sensitive"
    _regex: String
    "does the column match the given SQL regular expression"
    _similar: String
}

"append existing jsonb value of filtered columns with new jsonb value"
input buffgeom_attributes_append_input {
    index: jsonb
    normal: jsonb
    position: jsonb
    uv: jsonb
}

"Boolean expression to filter rows from the table \"buffgeom.attributes\". All fields are combined with a logical 'AND'."
input buffgeom_attributes_bool_exp {
    _and: [buffgeom_attributes_bool_exp!]
    _not: buffgeom_attributes_bool_exp
    _or: [buffgeom_attributes_bool_exp!]
    index: jsonb_comparison_exp
    normal: jsonb_comparison_exp
    position: jsonb_comparison_exp
    type: String_comparison_exp
    uuid: uuid_comparison_exp
    uv: jsonb_comparison_exp
}

"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
input buffgeom_attributes_delete_at_path_input {
    index: [String!]
    normal: [String!]
    position: [String!]
    uv: [String!]
}

"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
input buffgeom_attributes_delete_elem_input {
    index: Int
    normal: Int
    position: Int
    uv: Int
}

"delete key/value pair or string element. key/value pairs are matched based on their key value"
input buffgeom_attributes_delete_key_input {
    index: String
    normal: String
    position: String
    uv: String
}

"input type for inserting data into table \"buffgeom.attributes\""
input buffgeom_attributes_insert_input {
    index: jsonb
    normal: jsonb
    position: jsonb
    type: String
    uuid: uuid
    uv: jsonb
}

"on_conflict condition type for table \"buffgeom.attributes\""
input buffgeom_attributes_on_conflict {
    constraint: buffgeom_attributes_constraint!
    update_columns: [buffgeom_attributes_update_column!]! = []
    where: buffgeom_attributes_bool_exp
}

"Ordering options when selecting data from \"buffgeom.attributes\"."
input buffgeom_attributes_order_by {
    index: order_by
    normal: order_by
    position: order_by
    type: order_by
    uuid: order_by
    uv: order_by
}

"primary key columns input for table: buffgeom.attributes"
input buffgeom_attributes_pk_columns_input {
    uuid: uuid!
}

"prepend existing jsonb value of filtered columns with new jsonb value"
input buffgeom_attributes_prepend_input {
    index: jsonb
    normal: jsonb
    position: jsonb
    uv: jsonb
}

"input type for updating data in table \"buffgeom.attributes\""
input buffgeom_attributes_set_input {
    index: jsonb
    normal: jsonb
    position: jsonb
    type: String
    uuid: uuid
    uv: jsonb
}

"Streaming cursor of the table \"buffgeom_attributes\""
input buffgeom_attributes_stream_cursor_input {
    "Stream column input with initial value"
    initial_value: buffgeom_attributes_stream_cursor_value_input!
    "cursor ordering"
    ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input buffgeom_attributes_stream_cursor_value_input {
    index: jsonb
    normal: jsonb
    position: jsonb
    type: String
    uuid: uuid
    uv: jsonb
}

input buffgeom_attributes_updates {
    "append existing jsonb value of filtered columns with new jsonb value"
    _append: buffgeom_attributes_append_input
    "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
    _delete_at_path: buffgeom_attributes_delete_at_path_input
    "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
    _delete_elem: buffgeom_attributes_delete_elem_input
    "delete key/value pair or string element. key/value pairs are matched based on their key value"
    _delete_key: buffgeom_attributes_delete_key_input
    "prepend existing jsonb value of filtered columns with new jsonb value"
    _prepend: buffgeom_attributes_prepend_input
    "sets the columns of the filtered rows to the given values"
    _set: buffgeom_attributes_set_input
    "filter the rows which have to be updated"
    where: buffgeom_attributes_bool_exp!
}

"append existing jsonb value of filtered columns with new jsonb value"
input buffgeom_objects_append_input {
    children: jsonb
    matrix: jsonb
    userData: jsonb
}

"Boolean expression to filter rows from the table \"buffgeom.objects\". All fields are combined with a logical 'AND'."
input buffgeom_objects_bool_exp {
    _and: [buffgeom_objects_bool_exp!]
    _not: buffgeom_objects_bool_exp
    _or: [buffgeom_objects_bool_exp!]
    castShadow: Boolean_comparison_exp
    children: jsonb_comparison_exp
    geometry: uuid_comparison_exp
    layers: Int_comparison_exp
    material: uuid_comparison_exp
    matrix: jsonb_comparison_exp
    name: String_comparison_exp
    receiveShadow: Boolean_comparison_exp
    type: String_comparison_exp
    userData: jsonb_comparison_exp
    uuid: uuid_comparison_exp
}

"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
input buffgeom_objects_delete_at_path_input {
    children: [String!]
    matrix: [String!]
    userData: [String!]
}

"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
input buffgeom_objects_delete_elem_input {
    children: Int
    matrix: Int
    userData: Int
}

"delete key/value pair or string element. key/value pairs are matched based on their key value"
input buffgeom_objects_delete_key_input {
    children: String
    matrix: String
    userData: String
}

"input type for incrementing numeric columns in table \"buffgeom.objects\""
input buffgeom_objects_inc_input {
    layers: Int
}

"input type for inserting data into table \"buffgeom.objects\""
input buffgeom_objects_insert_input {
    castShadow: Boolean
    children: jsonb
    geometry: uuid
    layers: Int
    material: uuid
    matrix: jsonb
    name: String
    receiveShadow: Boolean
    type: String
    userData: jsonb
    uuid: uuid
}

"on_conflict condition type for table \"buffgeom.objects\""
input buffgeom_objects_on_conflict {
    constraint: buffgeom_objects_constraint!
    update_columns: [buffgeom_objects_update_column!]! = []
    where: buffgeom_objects_bool_exp
}

"Ordering options when selecting data from \"buffgeom.objects\"."
input buffgeom_objects_order_by {
    castShadow: order_by
    children: order_by
    geometry: order_by
    layers: order_by
    material: order_by
    matrix: order_by
    name: order_by
    receiveShadow: order_by
    type: order_by
    userData: order_by
    uuid: order_by
}

"primary key columns input for table: buffgeom.objects"
input buffgeom_objects_pk_columns_input {
    uuid: uuid!
}

"prepend existing jsonb value of filtered columns with new jsonb value"
input buffgeom_objects_prepend_input {
    children: jsonb
    matrix: jsonb
    userData: jsonb
}

"input type for updating data in table \"buffgeom.objects\""
input buffgeom_objects_set_input {
    castShadow: Boolean
    children: jsonb
    geometry: uuid
    layers: Int
    material: uuid
    matrix: jsonb
    name: String
    receiveShadow: Boolean
    type: String
    userData: jsonb
    uuid: uuid
}

"Streaming cursor of the table \"buffgeom_objects\""
input buffgeom_objects_stream_cursor_input {
    "Stream column input with initial value"
    initial_value: buffgeom_objects_stream_cursor_value_input!
    "cursor ordering"
    ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input buffgeom_objects_stream_cursor_value_input {
    castShadow: Boolean
    children: jsonb
    geometry: uuid
    layers: Int
    material: uuid
    matrix: jsonb
    name: String
    receiveShadow: Boolean
    type: String
    userData: jsonb
    uuid: uuid
}

input buffgeom_objects_updates {
    "append existing jsonb value of filtered columns with new jsonb value"
    _append: buffgeom_objects_append_input
    "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
    _delete_at_path: buffgeom_objects_delete_at_path_input
    "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
    _delete_elem: buffgeom_objects_delete_elem_input
    "delete key/value pair or string element. key/value pairs are matched based on their key value"
    _delete_key: buffgeom_objects_delete_key_input
    "increments the numeric columns with given value of the filtered values"
    _inc: buffgeom_objects_inc_input
    "prepend existing jsonb value of filtered columns with new jsonb value"
    _prepend: buffgeom_objects_prepend_input
    "sets the columns of the filtered rows to the given values"
    _set: buffgeom_objects_set_input
    "filter the rows which have to be updated"
    where: buffgeom_objects_bool_exp!
}

input jsonb_cast_exp {
    String: String_comparison_exp
}

"Boolean expression to compare columns of type \"jsonb\". All fields are combined with logical 'AND'."
input jsonb_comparison_exp {
    _cast: jsonb_cast_exp
    "is the column contained in the given json value"
    _contained_in: jsonb
    "does the column contain the given json value at the top level"
    _contains: jsonb
    _eq: jsonb
    _gt: jsonb
    _gte: jsonb
    "does the string exist as a top-level key in the column"
    _has_key: String
    "do all of these strings exist as top-level keys in the column"
    _has_keys_all: [String!]
    "do any of these strings exist as top-level keys in the column"
    _has_keys_any: [String!]
    _in: [jsonb!]
    _is_null: Boolean
    _lt: jsonb
    _lte: jsonb
    _neq: jsonb
    _nin: [jsonb!]
}

"Boolean expression to filter rows from the table \"projects.projects_hub\". All fields are combined with a logical 'AND'."
input projects_projects_hub_bool_exp {
    _and: [projects_projects_hub_bool_exp!]
    _not: projects_projects_hub_bool_exp
    _or: [projects_projects_hub_bool_exp!]
    id: uuid_comparison_exp
    last_visited: timestamptz_comparison_exp
    name: String_comparison_exp
    thumb: String_comparison_exp
}

"input type for inserting data into table \"projects.projects_hub\""
input projects_projects_hub_insert_input {
    id: uuid
    last_visited: timestamptz
    name: String
    thumb: String
}

"on_conflict condition type for table \"projects.projects_hub\""
input projects_projects_hub_on_conflict {
    constraint: projects_projects_hub_constraint!
    update_columns: [projects_projects_hub_update_column!]! = []
    where: projects_projects_hub_bool_exp
}

"Ordering options when selecting data from \"projects.projects_hub\"."
input projects_projects_hub_order_by {
    id: order_by
    last_visited: order_by
    name: order_by
    thumb: order_by
}

"primary key columns input for table: projects.projects_hub"
input projects_projects_hub_pk_columns_input {
    id: uuid!
}

"input type for updating data in table \"projects.projects_hub\""
input projects_projects_hub_set_input {
    id: uuid
    last_visited: timestamptz
    name: String
    thumb: String
}

"Streaming cursor of the table \"projects_projects_hub\""
input projects_projects_hub_stream_cursor_input {
    "Stream column input with initial value"
    initial_value: projects_projects_hub_stream_cursor_value_input!
    "cursor ordering"
    ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input projects_projects_hub_stream_cursor_value_input {
    id: uuid
    last_visited: timestamptz
    name: String
    thumb: String
}

input projects_projects_hub_updates {
    "sets the columns of the filtered rows to the given values"
    _set: projects_projects_hub_set_input
    "filter the rows which have to be updated"
    where: projects_projects_hub_bool_exp!
}

"append existing jsonb value of filtered columns with new jsonb value"
input projects_queries_hub_append_input {
    body: jsonb
    tags: jsonb
}

"Boolean expression to filter rows from the table \"projects.queries_hub\". All fields are combined with a logical 'AND'."
input projects_queries_hub_bool_exp {
    _and: [projects_queries_hub_bool_exp!]
    _not: projects_queries_hub_bool_exp
    _or: [projects_queries_hub_bool_exp!]
    body: jsonb_comparison_exp
    endpoint: String_comparison_exp
    id: uuid_comparison_exp
    name: String_comparison_exp
    project_name: String_comparison_exp
    tags: jsonb_comparison_exp
}

"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
input projects_queries_hub_delete_at_path_input {
    body: [String!]
    tags: [String!]
}

"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
input projects_queries_hub_delete_elem_input {
    body: Int
    tags: Int
}

"delete key/value pair or string element. key/value pairs are matched based on their key value"
input projects_queries_hub_delete_key_input {
    body: String
    tags: String
}

"input type for inserting data into table \"projects.queries_hub\""
input projects_queries_hub_insert_input {
    body: jsonb
    endpoint: String
    id: uuid
    name: String
    project_name: String
    tags: jsonb
}

"on_conflict condition type for table \"projects.queries_hub\""
input projects_queries_hub_on_conflict {
    constraint: projects_queries_hub_constraint!
    update_columns: [projects_queries_hub_update_column!]! = []
    where: projects_queries_hub_bool_exp
}

"Ordering options when selecting data from \"projects.queries_hub\"."
input projects_queries_hub_order_by {
    body: order_by
    endpoint: order_by
    id: order_by
    name: order_by
    project_name: order_by
    tags: order_by
}

"primary key columns input for table: projects.queries_hub"
input projects_queries_hub_pk_columns_input {
    id: uuid!
}

"prepend existing jsonb value of filtered columns with new jsonb value"
input projects_queries_hub_prepend_input {
    body: jsonb
    tags: jsonb
}

"input type for updating data in table \"projects.queries_hub\""
input projects_queries_hub_set_input {
    body: jsonb
    endpoint: String
    id: uuid
    name: String
    project_name: String
    tags: jsonb
}

"Streaming cursor of the table \"projects_queries_hub\""
input projects_queries_hub_stream_cursor_input {
    "Stream column input with initial value"
    initial_value: projects_queries_hub_stream_cursor_value_input!
    "cursor ordering"
    ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input projects_queries_hub_stream_cursor_value_input {
    body: jsonb
    endpoint: String
    id: uuid
    name: String
    project_name: String
    tags: jsonb
}

input projects_queries_hub_updates {
    "append existing jsonb value of filtered columns with new jsonb value"
    _append: projects_queries_hub_append_input
    "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
    _delete_at_path: projects_queries_hub_delete_at_path_input
    "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
    _delete_elem: projects_queries_hub_delete_elem_input
    "delete key/value pair or string element. key/value pairs are matched based on their key value"
    _delete_key: projects_queries_hub_delete_key_input
    "prepend existing jsonb value of filtered columns with new jsonb value"
    _prepend: projects_queries_hub_prepend_input
    "sets the columns of the filtered rows to the given values"
    _set: projects_queries_hub_set_input
    "filter the rows which have to be updated"
    where: projects_queries_hub_bool_exp!
}

"Boolean expression to compare columns of type \"timestamptz\". All fields are combined with logical 'AND'."
input timestamptz_comparison_exp {
    _eq: timestamptz
    _gt: timestamptz
    _gte: timestamptz
    _in: [timestamptz!]
    _is_null: Boolean
    _lt: timestamptz
    _lte: timestamptz
    _neq: timestamptz
    _nin: [timestamptz!]
}

"Boolean expression to compare columns of type \"uuid\". All fields are combined with logical 'AND'."
input uuid_comparison_exp {
    _eq: uuid
    _gt: uuid
    _gte: uuid
    _in: [uuid!]
    _is_null: Boolean
    _lt: uuid
    _lte: uuid
    _neq: uuid
    _nin: [uuid!]
}
