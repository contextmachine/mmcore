# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
    query: query_root
    mutation: mutation_root
    subscription: subscription_root
}

"whether this query should be cached (Hasura Cloud only)"
directive @cached(
    "refresh the cache entry"
    refresh: Boolean! = false,
    "measured in seconds"
    ttl: Int! = 60
) on QUERY

"A union of all types that use the @key directive"
union _Entity = buffgeom_objects | geometry_attributes | lc_properties

type _Service {
    "SDL representation of schema"
    sdl: String!
}

"geometry fields"
type buffgeom_objects {
    castShadow: Boolean!
    children(
        "JSON select path"
        path: String
    ): jsonb
    geometry: uuid!
    layers: Int!
    material: uuid!
    matrix(
        "JSON select path"
        path: String
    ): jsonb!
    name: String
    receiveShadow: Boolean!
    type: String!
    userData(
        "JSON select path"
        path: String
    ): jsonb
    uuid: uuid!
}

"aggregated selection of \"buffgeom.objects\""
type buffgeom_objects_aggregate {
    aggregate: buffgeom_objects_aggregate_fields
    nodes: [buffgeom_objects!]!
}

"aggregate fields of \"buffgeom.objects\""
type buffgeom_objects_aggregate_fields {
    avg: buffgeom_objects_avg_fields
    count(columns: [buffgeom_objects_select_column!], distinct: Boolean): Int!
    max: buffgeom_objects_max_fields
    min: buffgeom_objects_min_fields
    stddev: buffgeom_objects_stddev_fields
    stddev_pop: buffgeom_objects_stddev_pop_fields
    stddev_samp: buffgeom_objects_stddev_samp_fields
    sum: buffgeom_objects_sum_fields
    var_pop: buffgeom_objects_var_pop_fields
    var_samp: buffgeom_objects_var_samp_fields
    variance: buffgeom_objects_variance_fields
}

"aggregate avg on columns"
type buffgeom_objects_avg_fields {
    layers: Float
}

"aggregate max on columns"
type buffgeom_objects_max_fields {
    geometry: uuid
    layers: Int
    material: uuid
    name: String
    type: String
    uuid: uuid
}

"aggregate min on columns"
type buffgeom_objects_min_fields {
    geometry: uuid
    layers: Int
    material: uuid
    name: String
    type: String
    uuid: uuid
}

"response of any mutation on the table \"buffgeom.objects\""
type buffgeom_objects_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [buffgeom_objects!]!
}

"aggregate stddev on columns"
type buffgeom_objects_stddev_fields {
    layers: Float
}

"aggregate stddev_pop on columns"
type buffgeom_objects_stddev_pop_fields {
    layers: Float
}

"aggregate stddev_samp on columns"
type buffgeom_objects_stddev_samp_fields {
    layers: Float
}

"aggregate sum on columns"
type buffgeom_objects_sum_fields {
    layers: Int
}

"aggregate var_pop on columns"
type buffgeom_objects_var_pop_fields {
    layers: Float
}

"aggregate var_samp on columns"
type buffgeom_objects_var_samp_fields {
    layers: Float
}

"aggregate variance on columns"
type buffgeom_objects_variance_fields {
    layers: Float
}

"attractive"
type geometry_attributes {
    index(
        "JSON select path"
        path: String
    ): jsonb
    normal(
        "JSON select path"
        path: String
    ): jsonb
    position(
        "JSON select path"
        path: String
    ): jsonb
    type: String!
    uuid: uuid!
    uv(
        "JSON select path"
        path: String
    ): jsonb
}

"aggregated selection of \"buffgeom.attributes\""
type geometry_attributes_aggregate {
    aggregate: geometry_attributes_aggregate_fields
    nodes: [geometry_attributes!]!
}

"aggregate fields of \"buffgeom.attributes\""
type geometry_attributes_aggregate_fields {
    count(columns: [geometry_attributes_select_column!], distinct: Boolean): Int!
    max: geometry_attributes_max_fields
    min: geometry_attributes_min_fields
}

"aggregate max on columns"
type geometry_attributes_max_fields {
    type: String
    uuid: uuid
}

"aggregate min on columns"
type geometry_attributes_min_fields {
    type: String
    uuid: uuid
}

"response of any mutation on the table \"buffgeom.attributes\""
type geometry_attributes_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [geometry_attributes!]!
}

"columns and relationships of \"lht_ceiling.properties\""
type lc_properties {
    id: Int!
    part: String
    stage: String
    status: String!
    subtype: String!
    type: String!
    uuid: uuid!
    zone: String!
}

"aggregated selection of \"lht_ceiling.properties\""
type lc_properties_aggregate {
    aggregate: lc_properties_aggregate_fields
    nodes: [lc_properties!]!
}

"aggregate fields of \"lht_ceiling.properties\""
type lc_properties_aggregate_fields {
    avg: lc_properties_avg_fields
    count(columns: [lc_properties_select_column!], distinct: Boolean): Int!
    max: lc_properties_max_fields
    min: lc_properties_min_fields
    stddev: lc_properties_stddev_fields
    stddev_pop: lc_properties_stddev_pop_fields
    stddev_samp: lc_properties_stddev_samp_fields
    sum: lc_properties_sum_fields
    var_pop: lc_properties_var_pop_fields
    var_samp: lc_properties_var_samp_fields
    variance: lc_properties_variance_fields
}

"aggregate avg on columns"
type lc_properties_avg_fields {
    id: Float
}

"aggregate max on columns"
type lc_properties_max_fields {
    id: Int
    part: String
    stage: String
    status: String
    subtype: String
    type: String
    uuid: uuid
    zone: String
}

"aggregate min on columns"
type lc_properties_min_fields {
    id: Int
    part: String
    stage: String
    status: String
    subtype: String
    type: String
    uuid: uuid
    zone: String
}

"response of any mutation on the table \"lht_ceiling.properties\""
type lc_properties_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [lc_properties!]!
}

"aggregate stddev on columns"
type lc_properties_stddev_fields {
    id: Float
}

"aggregate stddev_pop on columns"
type lc_properties_stddev_pop_fields {
    id: Float
}

"aggregate stddev_samp on columns"
type lc_properties_stddev_samp_fields {
    id: Float
}

"aggregate sum on columns"
type lc_properties_sum_fields {
    id: Int
}

"aggregate var_pop on columns"
type lc_properties_var_pop_fields {
    id: Float
}

"aggregate var_samp on columns"
type lc_properties_var_samp_fields {
    id: Float
}

"aggregate variance on columns"
type lc_properties_variance_fields {
    id: Float
}

"mutation root"
type mutation_root {
    "delete data from the table: \"buffgeom.objects\""
    delete_buffgeom_objects(
        "filter the rows which have to be deleted"
        where: buffgeom_objects_bool_exp!
    ): buffgeom_objects_mutation_response
    "delete single row from the table: \"buffgeom.objects\""
    delete_buffgeom_objects_by_pk(uuid: uuid!): buffgeom_objects
    "delete data from the table: \"buffgeom.attributes\""
    delete_geometry_attributes(
        "filter the rows which have to be deleted"
        where: geometry_attributes_bool_exp!
    ): geometry_attributes_mutation_response
    "delete single row from the table: \"buffgeom.attributes\""
    delete_geometry_attributes_by_pk(uuid: uuid!): geometry_attributes
    "delete data from the table: \"lht_ceiling.properties\""
    delete_lc_properties(
        "filter the rows which have to be deleted"
        where: lc_properties_bool_exp!
    ): lc_properties_mutation_response
    "delete single row from the table: \"lht_ceiling.properties\""
    delete_lc_properties_by_pk(id: Int!, subtype: String!, type: String!, uuid: uuid!): lc_properties
    "delete data from the table: \"presets.colors\""
    delete_presets_colors(
        "filter the rows which have to be deleted"
        where: presets_colors_bool_exp!
    ): presets_colors_mutation_response
    "delete single row from the table: \"presets.colors\""
    delete_presets_colors_by_pk(id: Int!, palette: Int!): presets_colors
    "delete data from the table: \"projects.projects_hub\""
    delete_projects_projects_hub(
        "filter the rows which have to be deleted"
        where: projects_projects_hub_bool_exp!
    ): projects_projects_hub_mutation_response
    "delete single row from the table: \"projects.projects_hub\""
    delete_projects_projects_hub_by_pk(id: uuid!): projects_projects_hub
    "delete data from the table: \"projects.queries_hub\""
    delete_projects_queries_hub(
        "filter the rows which have to be deleted"
        where: projects_queries_hub_bool_exp!
    ): projects_queries_hub_mutation_response
    "delete single row from the table: \"projects.queries_hub\""
    delete_projects_queries_hub_by_pk(id: uuid!): projects_queries_hub
    "delete data from the table: \"tests.properties\""
    delete_properties(
        "filter the rows which have to be deleted"
        where: properties_bool_exp!
    ): properties_mutation_response
    "delete single row from the table: \"tests.properties\""
    delete_properties_by_pk(index: Int!, uuid: uuid!): properties
    "insert data into the table: \"buffgeom.objects\""
    insert_buffgeom_objects(
        "the rows to be inserted"
        objects: [buffgeom_objects_insert_input!]!,
        "upsert condition"
        on_conflict: buffgeom_objects_on_conflict
    ): buffgeom_objects_mutation_response
    "insert a single row into the table: \"buffgeom.objects\""
    insert_buffgeom_objects_one(
        "the row to be inserted"
        object: buffgeom_objects_insert_input!,
        "upsert condition"
        on_conflict: buffgeom_objects_on_conflict
    ): buffgeom_objects
    "insert data into the table: \"buffgeom.attributes\""
    insert_geometry_attributes(
        "the rows to be inserted"
        objects: [geometry_attributes_insert_input!]!,
        "upsert condition"
        on_conflict: geometry_attributes_on_conflict
    ): geometry_attributes_mutation_response
    "insert a single row into the table: \"buffgeom.attributes\""
    insert_geometry_attributes_one(
        "the row to be inserted"
        object: geometry_attributes_insert_input!,
        "upsert condition"
        on_conflict: geometry_attributes_on_conflict
    ): geometry_attributes
    "insert data into the table: \"lht_ceiling.properties\""
    insert_lc_properties(
        "the rows to be inserted"
        objects: [lc_properties_insert_input!]!,
        "upsert condition"
        on_conflict: lc_properties_on_conflict
    ): lc_properties_mutation_response
    "insert a single row into the table: \"lht_ceiling.properties\""
    insert_lc_properties_one(
        "the row to be inserted"
        object: lc_properties_insert_input!,
        "upsert condition"
        on_conflict: lc_properties_on_conflict
    ): lc_properties
    "insert data into the table: \"presets.colors\""
    insert_presets_colors(
        "the rows to be inserted"
        objects: [presets_colors_insert_input!]!,
        "upsert condition"
        on_conflict: presets_colors_on_conflict
    ): presets_colors_mutation_response
    "insert a single row into the table: \"presets.colors\""
    insert_presets_colors_one(
        "the row to be inserted"
        object: presets_colors_insert_input!,
        "upsert condition"
        on_conflict: presets_colors_on_conflict
    ): presets_colors
    "insert data into the table: \"projects.projects_hub\""
    insert_projects_projects_hub(
        "the rows to be inserted"
        objects: [projects_projects_hub_insert_input!]!,
        "upsert condition"
        on_conflict: projects_projects_hub_on_conflict
    ): projects_projects_hub_mutation_response
    "insert a single row into the table: \"projects.projects_hub\""
    insert_projects_projects_hub_one(
        "the row to be inserted"
        object: projects_projects_hub_insert_input!,
        "upsert condition"
        on_conflict: projects_projects_hub_on_conflict
    ): projects_projects_hub
    "insert data into the table: \"projects.queries_hub\""
    insert_projects_queries_hub(
        "the rows to be inserted"
        objects: [projects_queries_hub_insert_input!]!,
        "upsert condition"
        on_conflict: projects_queries_hub_on_conflict
    ): projects_queries_hub_mutation_response
    "insert a single row into the table: \"projects.queries_hub\""
    insert_projects_queries_hub_one(
        "the row to be inserted"
        object: projects_queries_hub_insert_input!,
        "upsert condition"
        on_conflict: projects_queries_hub_on_conflict
    ): projects_queries_hub
    "insert data into the table: \"tests.properties\""
    insert_properties(
        "the rows to be inserted"
        objects: [properties_insert_input!]!,
        "upsert condition"
        on_conflict: properties_on_conflict
    ): properties_mutation_response
    "insert a single row into the table: \"tests.properties\""
    insert_properties_one(
        "the row to be inserted"
        object: properties_insert_input!,
        "upsert condition"
        on_conflict: properties_on_conflict
    ): properties
    "update data of the table: \"buffgeom.objects\""
    update_buffgeom_objects(
        "append existing jsonb value of filtered columns with new jsonb value"
        _append: buffgeom_objects_append_input,
        "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
        _delete_at_path: buffgeom_objects_delete_at_path_input,
        "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
        _delete_elem: buffgeom_objects_delete_elem_input,
        "delete key/value pair or string element. key/value pairs are matched based on their key value"
        _delete_key: buffgeom_objects_delete_key_input,
        "increments the numeric columns with given value of the filtered values"
        _inc: buffgeom_objects_inc_input,
        "prepend existing jsonb value of filtered columns with new jsonb value"
        _prepend: buffgeom_objects_prepend_input,
        "sets the columns of the filtered rows to the given values"
        _set: buffgeom_objects_set_input,
        "filter the rows which have to be updated"
        where: buffgeom_objects_bool_exp!
    ): buffgeom_objects_mutation_response
    "update single row of the table: \"buffgeom.objects\""
    update_buffgeom_objects_by_pk(
        "append existing jsonb value of filtered columns with new jsonb value"
        _append: buffgeom_objects_append_input,
        "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
        _delete_at_path: buffgeom_objects_delete_at_path_input,
        "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
        _delete_elem: buffgeom_objects_delete_elem_input,
        "delete key/value pair or string element. key/value pairs are matched based on their key value"
        _delete_key: buffgeom_objects_delete_key_input,
        "increments the numeric columns with given value of the filtered values"
        _inc: buffgeom_objects_inc_input,
        "prepend existing jsonb value of filtered columns with new jsonb value"
        _prepend: buffgeom_objects_prepend_input,
        "sets the columns of the filtered rows to the given values"
        _set: buffgeom_objects_set_input,
        pk_columns: buffgeom_objects_pk_columns_input!
    ): buffgeom_objects
    "update multiples rows of table: \"buffgeom.objects\""
    update_buffgeom_objects_many(
        "updates to execute, in order"
        updates: [buffgeom_objects_updates!]!
    ): [buffgeom_objects_mutation_response]
    "update data of the table: \"buffgeom.attributes\""
    update_geometry_attributes(
        "append existing jsonb value of filtered columns with new jsonb value"
        _append: geometry_attributes_append_input,
        "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
        _delete_at_path: geometry_attributes_delete_at_path_input,
        "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
        _delete_elem: geometry_attributes_delete_elem_input,
        "delete key/value pair or string element. key/value pairs are matched based on their key value"
        _delete_key: geometry_attributes_delete_key_input,
        "prepend existing jsonb value of filtered columns with new jsonb value"
        _prepend: geometry_attributes_prepend_input,
        "sets the columns of the filtered rows to the given values"
        _set: geometry_attributes_set_input,
        "filter the rows which have to be updated"
        where: geometry_attributes_bool_exp!
    ): geometry_attributes_mutation_response
    "update single row of the table: \"buffgeom.attributes\""
    update_geometry_attributes_by_pk(
        "append existing jsonb value of filtered columns with new jsonb value"
        _append: geometry_attributes_append_input,
        "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
        _delete_at_path: geometry_attributes_delete_at_path_input,
        "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
        _delete_elem: geometry_attributes_delete_elem_input,
        "delete key/value pair or string element. key/value pairs are matched based on their key value"
        _delete_key: geometry_attributes_delete_key_input,
        "prepend existing jsonb value of filtered columns with new jsonb value"
        _prepend: geometry_attributes_prepend_input,
        "sets the columns of the filtered rows to the given values"
        _set: geometry_attributes_set_input,
        pk_columns: geometry_attributes_pk_columns_input!
    ): geometry_attributes
    "update multiples rows of table: \"buffgeom.attributes\""
    update_geometry_attributes_many(
        "updates to execute, in order"
        updates: [geometry_attributes_updates!]!
    ): [geometry_attributes_mutation_response]
    "update data of the table: \"lht_ceiling.properties\""
    update_lc_properties(
        "increments the numeric columns with given value of the filtered values"
        _inc: lc_properties_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: lc_properties_set_input,
        "filter the rows which have to be updated"
        where: lc_properties_bool_exp!
    ): lc_properties_mutation_response
    "update single row of the table: \"lht_ceiling.properties\""
    update_lc_properties_by_pk(
        "increments the numeric columns with given value of the filtered values"
        _inc: lc_properties_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: lc_properties_set_input,
        pk_columns: lc_properties_pk_columns_input!
    ): lc_properties
    "update multiples rows of table: \"lht_ceiling.properties\""
    update_lc_properties_many(
        "updates to execute, in order"
        updates: [lc_properties_updates!]!
    ): [lc_properties_mutation_response]
    "update data of the table: \"presets.colors\""
    update_presets_colors(
        "increments the numeric columns with given value of the filtered values"
        _inc: presets_colors_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: presets_colors_set_input,
        "filter the rows which have to be updated"
        where: presets_colors_bool_exp!
    ): presets_colors_mutation_response
    "update single row of the table: \"presets.colors\""
    update_presets_colors_by_pk(
        "increments the numeric columns with given value of the filtered values"
        _inc: presets_colors_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: presets_colors_set_input,
        pk_columns: presets_colors_pk_columns_input!
    ): presets_colors
    "update multiples rows of table: \"presets.colors\""
    update_presets_colors_many(
        "updates to execute, in order"
        updates: [presets_colors_updates!]!
    ): [presets_colors_mutation_response]
    "update data of the table: \"projects.projects_hub\""
    update_projects_projects_hub(
        "sets the columns of the filtered rows to the given values"
        _set: projects_projects_hub_set_input,
        "filter the rows which have to be updated"
        where: projects_projects_hub_bool_exp!
    ): projects_projects_hub_mutation_response
    "update single row of the table: \"projects.projects_hub\""
    update_projects_projects_hub_by_pk(
        "sets the columns of the filtered rows to the given values"
        _set: projects_projects_hub_set_input,
        pk_columns: projects_projects_hub_pk_columns_input!
    ): projects_projects_hub
    "update multiples rows of table: \"projects.projects_hub\""
    update_projects_projects_hub_many(
        "updates to execute, in order"
        updates: [projects_projects_hub_updates!]!
    ): [projects_projects_hub_mutation_response]
    "update data of the table: \"projects.queries_hub\""
    update_projects_queries_hub(
        "append existing jsonb value of filtered columns with new jsonb value"
        _append: projects_queries_hub_append_input,
        "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
        _delete_at_path: projects_queries_hub_delete_at_path_input,
        "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
        _delete_elem: projects_queries_hub_delete_elem_input,
        "delete key/value pair or string element. key/value pairs are matched based on their key value"
        _delete_key: projects_queries_hub_delete_key_input,
        "prepend existing jsonb value of filtered columns with new jsonb value"
        _prepend: projects_queries_hub_prepend_input,
        "sets the columns of the filtered rows to the given values"
        _set: projects_queries_hub_set_input,
        "filter the rows which have to be updated"
        where: projects_queries_hub_bool_exp!
    ): projects_queries_hub_mutation_response
    "update single row of the table: \"projects.queries_hub\""
    update_projects_queries_hub_by_pk(
        "append existing jsonb value of filtered columns with new jsonb value"
        _append: projects_queries_hub_append_input,
        "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
        _delete_at_path: projects_queries_hub_delete_at_path_input,
        "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
        _delete_elem: projects_queries_hub_delete_elem_input,
        "delete key/value pair or string element. key/value pairs are matched based on their key value"
        _delete_key: projects_queries_hub_delete_key_input,
        "prepend existing jsonb value of filtered columns with new jsonb value"
        _prepend: projects_queries_hub_prepend_input,
        "sets the columns of the filtered rows to the given values"
        _set: projects_queries_hub_set_input,
        pk_columns: projects_queries_hub_pk_columns_input!
    ): projects_queries_hub
    "update multiples rows of table: \"projects.queries_hub\""
    update_projects_queries_hub_many(
        "updates to execute, in order"
        updates: [projects_queries_hub_updates!]!
    ): [projects_queries_hub_mutation_response]
    "update data of the table: \"tests.properties\""
    update_properties(
        "increments the numeric columns with given value of the filtered values"
        _inc: properties_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: properties_set_input,
        "filter the rows which have to be updated"
        where: properties_bool_exp!
    ): properties_mutation_response
    "update single row of the table: \"tests.properties\""
    update_properties_by_pk(
        "increments the numeric columns with given value of the filtered values"
        _inc: properties_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: properties_set_input,
        pk_columns: properties_pk_columns_input!
    ): properties
    "update multiples rows of table: \"tests.properties\""
    update_properties_many(
        "updates to execute, in order"
        updates: [properties_updates!]!
    ): [properties_mutation_response]
}

"colours using in scene"
type presets_colors {
    b: Int
    decimal: Int
    g: Int
    hex: String
    id: Int!
    name: name
    palette: Int!
    r: Int
}

"aggregated selection of \"presets.colors\""
type presets_colors_aggregate {
    aggregate: presets_colors_aggregate_fields
    nodes: [presets_colors!]!
}

"aggregate fields of \"presets.colors\""
type presets_colors_aggregate_fields {
    avg: presets_colors_avg_fields
    count(columns: [presets_colors_select_column!], distinct: Boolean): Int!
    max: presets_colors_max_fields
    min: presets_colors_min_fields
    stddev: presets_colors_stddev_fields
    stddev_pop: presets_colors_stddev_pop_fields
    stddev_samp: presets_colors_stddev_samp_fields
    sum: presets_colors_sum_fields
    var_pop: presets_colors_var_pop_fields
    var_samp: presets_colors_var_samp_fields
    variance: presets_colors_variance_fields
}

"aggregate avg on columns"
type presets_colors_avg_fields {
    b: Float
    decimal: Float
    g: Float
    id: Float
    palette: Float
    r: Float
}

"aggregate max on columns"
type presets_colors_max_fields {
    b: Int
    decimal: Int
    g: Int
    hex: String
    id: Int
    palette: Int
    r: Int
}

"aggregate min on columns"
type presets_colors_min_fields {
    b: Int
    decimal: Int
    g: Int
    hex: String
    id: Int
    palette: Int
    r: Int
}

"response of any mutation on the table \"presets.colors\""
type presets_colors_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [presets_colors!]!
}

"aggregate stddev on columns"
type presets_colors_stddev_fields {
    b: Float
    decimal: Float
    g: Float
    id: Float
    palette: Float
    r: Float
}

"aggregate stddev_pop on columns"
type presets_colors_stddev_pop_fields {
    b: Float
    decimal: Float
    g: Float
    id: Float
    palette: Float
    r: Float
}

"aggregate stddev_samp on columns"
type presets_colors_stddev_samp_fields {
    b: Float
    decimal: Float
    g: Float
    id: Float
    palette: Float
    r: Float
}

"aggregate sum on columns"
type presets_colors_sum_fields {
    b: Int
    decimal: Int
    g: Int
    id: Int
    palette: Int
    r: Int
}

"aggregate var_pop on columns"
type presets_colors_var_pop_fields {
    b: Float
    decimal: Float
    g: Float
    id: Float
    palette: Float
    r: Float
}

"aggregate var_samp on columns"
type presets_colors_var_samp_fields {
    b: Float
    decimal: Float
    g: Float
    id: Float
    palette: Float
    r: Float
}

"aggregate variance on columns"
type presets_colors_variance_fields {
    b: Float
    decimal: Float
    g: Float
    id: Float
    palette: Float
    r: Float
}

"columns and relationships of \"projects.projects_hub\""
type projects_projects_hub {
    id: uuid!
    last_visited: timestamptz
    name: String
    thumb: String
}

"aggregated selection of \"projects.projects_hub\""
type projects_projects_hub_aggregate {
    aggregate: projects_projects_hub_aggregate_fields
    nodes: [projects_projects_hub!]!
}

"aggregate fields of \"projects.projects_hub\""
type projects_projects_hub_aggregate_fields {
    count(columns: [projects_projects_hub_select_column!], distinct: Boolean): Int!
    max: projects_projects_hub_max_fields
    min: projects_projects_hub_min_fields
}

"aggregate max on columns"
type projects_projects_hub_max_fields {
    id: uuid
    last_visited: timestamptz
    name: String
    thumb: String
}

"aggregate min on columns"
type projects_projects_hub_min_fields {
    id: uuid
    last_visited: timestamptz
    name: String
    thumb: String
}

"response of any mutation on the table \"projects.projects_hub\""
type projects_projects_hub_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [projects_projects_hub!]!
}

"columns and relationships of \"projects.queries_hub\""
type projects_queries_hub {
    body(
        "JSON select path"
        path: String
    ): jsonb!
    cr: timestamptz
    endpoint: String!
    id: uuid!
    name: String!
    project_name: String
    tags(
        "JSON select path"
        path: String
    ): jsonb!
}

"aggregated selection of \"projects.queries_hub\""
type projects_queries_hub_aggregate {
    aggregate: projects_queries_hub_aggregate_fields
    nodes: [projects_queries_hub!]!
}

"aggregate fields of \"projects.queries_hub\""
type projects_queries_hub_aggregate_fields {
    count(columns: [projects_queries_hub_select_column!], distinct: Boolean): Int!
    max: projects_queries_hub_max_fields
    min: projects_queries_hub_min_fields
}

"aggregate max on columns"
type projects_queries_hub_max_fields {
    cr: timestamptz
    endpoint: String
    id: uuid
    name: String
    project_name: String
}

"aggregate min on columns"
type projects_queries_hub_min_fields {
    cr: timestamptz
    endpoint: String
    id: uuid
    name: String
    project_name: String
}

"response of any mutation on the table \"projects.queries_hub\""
type projects_queries_hub_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [projects_queries_hub!]!
}

"columns and relationships of \"tests.properties\""
type properties {
    area: numeric!
    index: Int!
    part: String
    stage: String
    status: String
    subtype: Int!
    type: String!
    uuid: uuid!
}

"aggregated selection of \"tests.properties\""
type properties_aggregate {
    aggregate: properties_aggregate_fields
    nodes: [properties!]!
}

"aggregate fields of \"tests.properties\""
type properties_aggregate_fields {
    avg: properties_avg_fields
    count(columns: [properties_select_column!], distinct: Boolean): Int!
    max: properties_max_fields
    min: properties_min_fields
    stddev: properties_stddev_fields
    stddev_pop: properties_stddev_pop_fields
    stddev_samp: properties_stddev_samp_fields
    sum: properties_sum_fields
    var_pop: properties_var_pop_fields
    var_samp: properties_var_samp_fields
    variance: properties_variance_fields
}

"aggregate avg on columns"
type properties_avg_fields {
    area: Float
    index: Float
    subtype: Float
}

"aggregate max on columns"
type properties_max_fields {
    area: numeric
    index: Int
    part: String
    stage: String
    status: String
    subtype: Int
    type: String
    uuid: uuid
}

"aggregate min on columns"
type properties_min_fields {
    area: numeric
    index: Int
    part: String
    stage: String
    status: String
    subtype: Int
    type: String
    uuid: uuid
}

"response of any mutation on the table \"tests.properties\""
type properties_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [properties!]!
}

"aggregate stddev on columns"
type properties_stddev_fields {
    area: Float
    index: Float
    subtype: Float
}

"aggregate stddev_pop on columns"
type properties_stddev_pop_fields {
    area: Float
    index: Float
    subtype: Float
}

"aggregate stddev_samp on columns"
type properties_stddev_samp_fields {
    area: Float
    index: Float
    subtype: Float
}

"aggregate sum on columns"
type properties_sum_fields {
    area: numeric
    index: Int
    subtype: Int
}

"aggregate var_pop on columns"
type properties_var_pop_fields {
    area: Float
    index: Float
    subtype: Float
}

"aggregate var_samp on columns"
type properties_var_samp_fields {
    area: Float
    index: Float
    subtype: Float
}

"aggregate variance on columns"
type properties_variance_fields {
    area: Float
    index: Float
    subtype: Float
}

type query_root {
    "query _Entity union"
    _entities(representations: [_Any!]!): _Entity
    _service: _Service!
    "fetch data from the table: \"buffgeom.objects\""
    buffgeom_objects(
        "distinct select on columns"
        distinct_on: [buffgeom_objects_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [buffgeom_objects_order_by!],
        "filter the rows returned"
        where: buffgeom_objects_bool_exp
    ): [buffgeom_objects!]!
    "fetch aggregated fields from the table: \"buffgeom.objects\""
    buffgeom_objects_aggregate(
        "distinct select on columns"
        distinct_on: [buffgeom_objects_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [buffgeom_objects_order_by!],
        "filter the rows returned"
        where: buffgeom_objects_bool_exp
    ): buffgeom_objects_aggregate!
    "fetch data from the table: \"buffgeom.objects\" using primary key columns"
    buffgeom_objects_by_pk(uuid: uuid!): buffgeom_objects
    "fetch data from the table: \"buffgeom.attributes\""
    geometry_attributes(
        "distinct select on columns"
        distinct_on: [geometry_attributes_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [geometry_attributes_order_by!],
        "filter the rows returned"
        where: geometry_attributes_bool_exp
    ): [geometry_attributes!]!
    "fetch aggregated fields from the table: \"buffgeom.attributes\""
    geometry_attributes_aggregate(
        "distinct select on columns"
        distinct_on: [geometry_attributes_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [geometry_attributes_order_by!],
        "filter the rows returned"
        where: geometry_attributes_bool_exp
    ): geometry_attributes_aggregate!
    "fetch data from the table: \"buffgeom.attributes\" using primary key columns"
    geometry_attributes_by_pk(uuid: uuid!): geometry_attributes
    "fetch data from the table: \"lht_ceiling.properties\""
    lc_properties(
        "distinct select on columns"
        distinct_on: [lc_properties_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [lc_properties_order_by!],
        "filter the rows returned"
        where: lc_properties_bool_exp
    ): [lc_properties!]!
    "fetch aggregated fields from the table: \"lht_ceiling.properties\""
    lc_properties_aggregate(
        "distinct select on columns"
        distinct_on: [lc_properties_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [lc_properties_order_by!],
        "filter the rows returned"
        where: lc_properties_bool_exp
    ): lc_properties_aggregate!
    "fetch data from the table: \"lht_ceiling.properties\" using primary key columns"
    lc_properties_by_pk(id: Int!, subtype: String!, type: String!, uuid: uuid!): lc_properties
    "fetch data from the table: \"presets.colors\""
    presets_colors(
        "distinct select on columns"
        distinct_on: [presets_colors_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [presets_colors_order_by!],
        "filter the rows returned"
        where: presets_colors_bool_exp
    ): [presets_colors!]!
    "fetch aggregated fields from the table: \"presets.colors\""
    presets_colors_aggregate(
        "distinct select on columns"
        distinct_on: [presets_colors_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [presets_colors_order_by!],
        "filter the rows returned"
        where: presets_colors_bool_exp
    ): presets_colors_aggregate!
    "fetch data from the table: \"presets.colors\" using primary key columns"
    presets_colors_by_pk(id: Int!, palette: Int!): presets_colors
    "fetch data from the table: \"projects.projects_hub\""
    projects_projects_hub(
        "distinct select on columns"
        distinct_on: [projects_projects_hub_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [projects_projects_hub_order_by!],
        "filter the rows returned"
        where: projects_projects_hub_bool_exp
    ): [projects_projects_hub!]!
    "fetch aggregated fields from the table: \"projects.projects_hub\""
    projects_projects_hub_aggregate(
        "distinct select on columns"
        distinct_on: [projects_projects_hub_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [projects_projects_hub_order_by!],
        "filter the rows returned"
        where: projects_projects_hub_bool_exp
    ): projects_projects_hub_aggregate!
    "fetch data from the table: \"projects.projects_hub\" using primary key columns"
    projects_projects_hub_by_pk(id: uuid!): projects_projects_hub
    "fetch data from the table: \"projects.queries_hub\""
    projects_queries_hub(
        "distinct select on columns"
        distinct_on: [projects_queries_hub_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [projects_queries_hub_order_by!],
        "filter the rows returned"
        where: projects_queries_hub_bool_exp
    ): [projects_queries_hub!]!
    "fetch aggregated fields from the table: \"projects.queries_hub\""
    projects_queries_hub_aggregate(
        "distinct select on columns"
        distinct_on: [projects_queries_hub_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [projects_queries_hub_order_by!],
        "filter the rows returned"
        where: projects_queries_hub_bool_exp
    ): projects_queries_hub_aggregate!
    "fetch data from the table: \"projects.queries_hub\" using primary key columns"
    projects_queries_hub_by_pk(id: uuid!): projects_queries_hub
    "fetch data from the table: \"tests.properties\""
    properties(
        "distinct select on columns"
        distinct_on: [properties_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [properties_order_by!],
        "filter the rows returned"
        where: properties_bool_exp
    ): [properties!]!
    "fetch aggregated fields from the table: \"tests.properties\""
    properties_aggregate(
        "distinct select on columns"
        distinct_on: [properties_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [properties_order_by!],
        "filter the rows returned"
        where: properties_bool_exp
    ): properties_aggregate!
    "fetch data from the table: \"tests.properties\" using primary key columns"
    properties_by_pk(index: Int!, uuid: uuid!): properties
}

type subscription_root {
    "fetch data from the table: \"buffgeom.objects\""
    buffgeom_objects(
        "distinct select on columns"
        distinct_on: [buffgeom_objects_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [buffgeom_objects_order_by!],
        "filter the rows returned"
        where: buffgeom_objects_bool_exp
    ): [buffgeom_objects!]!
    "fetch aggregated fields from the table: \"buffgeom.objects\""
    buffgeom_objects_aggregate(
        "distinct select on columns"
        distinct_on: [buffgeom_objects_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [buffgeom_objects_order_by!],
        "filter the rows returned"
        where: buffgeom_objects_bool_exp
    ): buffgeom_objects_aggregate!
    "fetch data from the table: \"buffgeom.objects\" using primary key columns"
    buffgeom_objects_by_pk(uuid: uuid!): buffgeom_objects
    "fetch data from the table in a streaming manner: \"buffgeom.objects\""
    buffgeom_objects_stream(
        "maximum number of rows returned in a single batch"
        batch_size: Int!,
        "cursor to stream the results returned by the query"
        cursor: [buffgeom_objects_stream_cursor_input]!,
        "filter the rows returned"
        where: buffgeom_objects_bool_exp
    ): [buffgeom_objects!]!
    "fetch data from the table: \"buffgeom.attributes\""
    geometry_attributes(
        "distinct select on columns"
        distinct_on: [geometry_attributes_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [geometry_attributes_order_by!],
        "filter the rows returned"
        where: geometry_attributes_bool_exp
    ): [geometry_attributes!]!
    "fetch aggregated fields from the table: \"buffgeom.attributes\""
    geometry_attributes_aggregate(
        "distinct select on columns"
        distinct_on: [geometry_attributes_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [geometry_attributes_order_by!],
        "filter the rows returned"
        where: geometry_attributes_bool_exp
    ): geometry_attributes_aggregate!
    "fetch data from the table: \"buffgeom.attributes\" using primary key columns"
    geometry_attributes_by_pk(uuid: uuid!): geometry_attributes
    "fetch data from the table in a streaming manner: \"buffgeom.attributes\""
    geometry_attributes_stream(
        "maximum number of rows returned in a single batch"
        batch_size: Int!,
        "cursor to stream the results returned by the query"
        cursor: [geometry_attributes_stream_cursor_input]!,
        "filter the rows returned"
        where: geometry_attributes_bool_exp
    ): [geometry_attributes!]!
    "fetch data from the table: \"lht_ceiling.properties\""
    lc_properties(
        "distinct select on columns"
        distinct_on: [lc_properties_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [lc_properties_order_by!],
        "filter the rows returned"
        where: lc_properties_bool_exp
    ): [lc_properties!]!
    "fetch aggregated fields from the table: \"lht_ceiling.properties\""
    lc_properties_aggregate(
        "distinct select on columns"
        distinct_on: [lc_properties_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [lc_properties_order_by!],
        "filter the rows returned"
        where: lc_properties_bool_exp
    ): lc_properties_aggregate!
    "fetch data from the table: \"lht_ceiling.properties\" using primary key columns"
    lc_properties_by_pk(id: Int!, subtype: String!, type: String!, uuid: uuid!): lc_properties
    "fetch data from the table in a streaming manner: \"lht_ceiling.properties\""
    lc_properties_stream(
        "maximum number of rows returned in a single batch"
        batch_size: Int!,
        "cursor to stream the results returned by the query"
        cursor: [lc_properties_stream_cursor_input]!,
        "filter the rows returned"
        where: lc_properties_bool_exp
    ): [lc_properties!]!
    "fetch data from the table: \"presets.colors\""
    presets_colors(
        "distinct select on columns"
        distinct_on: [presets_colors_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [presets_colors_order_by!],
        "filter the rows returned"
        where: presets_colors_bool_exp
    ): [presets_colors!]!
    "fetch aggregated fields from the table: \"presets.colors\""
    presets_colors_aggregate(
        "distinct select on columns"
        distinct_on: [presets_colors_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [presets_colors_order_by!],
        "filter the rows returned"
        where: presets_colors_bool_exp
    ): presets_colors_aggregate!
    "fetch data from the table: \"presets.colors\" using primary key columns"
    presets_colors_by_pk(id: Int!, palette: Int!): presets_colors
    "fetch data from the table in a streaming manner: \"presets.colors\""
    presets_colors_stream(
        "maximum number of rows returned in a single batch"
        batch_size: Int!,
        "cursor to stream the results returned by the query"
        cursor: [presets_colors_stream_cursor_input]!,
        "filter the rows returned"
        where: presets_colors_bool_exp
    ): [presets_colors!]!
    "fetch data from the table: \"projects.projects_hub\""
    projects_projects_hub(
        "distinct select on columns"
        distinct_on: [projects_projects_hub_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [projects_projects_hub_order_by!],
        "filter the rows returned"
        where: projects_projects_hub_bool_exp
    ): [projects_projects_hub!]!
    "fetch aggregated fields from the table: \"projects.projects_hub\""
    projects_projects_hub_aggregate(
        "distinct select on columns"
        distinct_on: [projects_projects_hub_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [projects_projects_hub_order_by!],
        "filter the rows returned"
        where: projects_projects_hub_bool_exp
    ): projects_projects_hub_aggregate!
    "fetch data from the table: \"projects.projects_hub\" using primary key columns"
    projects_projects_hub_by_pk(id: uuid!): projects_projects_hub
    "fetch data from the table in a streaming manner: \"projects.projects_hub\""
    projects_projects_hub_stream(
        "maximum number of rows returned in a single batch"
        batch_size: Int!,
        "cursor to stream the results returned by the query"
        cursor: [projects_projects_hub_stream_cursor_input]!,
        "filter the rows returned"
        where: projects_projects_hub_bool_exp
    ): [projects_projects_hub!]!
    "fetch data from the table: \"projects.queries_hub\""
    projects_queries_hub(
        "distinct select on columns"
        distinct_on: [projects_queries_hub_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [projects_queries_hub_order_by!],
        "filter the rows returned"
        where: projects_queries_hub_bool_exp
    ): [projects_queries_hub!]!
    "fetch aggregated fields from the table: \"projects.queries_hub\""
    projects_queries_hub_aggregate(
        "distinct select on columns"
        distinct_on: [projects_queries_hub_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [projects_queries_hub_order_by!],
        "filter the rows returned"
        where: projects_queries_hub_bool_exp
    ): projects_queries_hub_aggregate!
    "fetch data from the table: \"projects.queries_hub\" using primary key columns"
    projects_queries_hub_by_pk(id: uuid!): projects_queries_hub
    "fetch data from the table in a streaming manner: \"projects.queries_hub\""
    projects_queries_hub_stream(
        "maximum number of rows returned in a single batch"
        batch_size: Int!,
        "cursor to stream the results returned by the query"
        cursor: [projects_queries_hub_stream_cursor_input]!,
        "filter the rows returned"
        where: projects_queries_hub_bool_exp
    ): [projects_queries_hub!]!
    "fetch data from the table: \"tests.properties\""
    properties(
        "distinct select on columns"
        distinct_on: [properties_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [properties_order_by!],
        "filter the rows returned"
        where: properties_bool_exp
    ): [properties!]!
    "fetch aggregated fields from the table: \"tests.properties\""
    properties_aggregate(
        "distinct select on columns"
        distinct_on: [properties_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [properties_order_by!],
        "filter the rows returned"
        where: properties_bool_exp
    ): properties_aggregate!
    "fetch data from the table: \"tests.properties\" using primary key columns"
    properties_by_pk(index: Int!, uuid: uuid!): properties
    "fetch data from the table in a streaming manner: \"tests.properties\""
    properties_stream(
        "maximum number of rows returned in a single batch"
        batch_size: Int!,
        "cursor to stream the results returned by the query"
        cursor: [properties_stream_cursor_input]!,
        "filter the rows returned"
        where: properties_bool_exp
    ): [properties!]!
}

"unique or primary key constraints on table \"buffgeom.objects\""
enum buffgeom_objects_constraint {
    "unique or primary key constraint on columns \"uuid\""
    objects_pkey
}

"select columns of table \"buffgeom.objects\""
enum buffgeom_objects_select_column {
    "column name"
    castShadow
    "column name"
    children
    "column name"
    geometry
    "column name"
    layers
    "column name"
    material
    "column name"
    matrix
    "column name"
    name
    "column name"
    receiveShadow
    "column name"
    type
    "column name"
    userData
    "column name"
    uuid
}

"update columns of table \"buffgeom.objects\""
enum buffgeom_objects_update_column {
    "column name"
    castShadow
    "column name"
    children
    "column name"
    geometry
    "column name"
    layers
    "column name"
    material
    "column name"
    matrix
    "column name"
    name
    "column name"
    receiveShadow
    "column name"
    type
    "column name"
    userData
    "column name"
    uuid
}

"ordering argument of a cursor"
enum cursor_ordering {
    "ascending ordering of the cursor"
    ASC
    "descending ordering of the cursor"
    DESC
}

"unique or primary key constraints on table \"buffgeom.attributes\""
enum geometry_attributes_constraint {
    "unique or primary key constraint on columns \"uuid\""
    attributes_pkey
    "unique or primary key constraint on columns \"uuid\""
    attributes_uuid_key
}

"select columns of table \"buffgeom.attributes\""
enum geometry_attributes_select_column {
    "column name"
    index
    "column name"
    normal
    "column name"
    position
    "column name"
    type
    "column name"
    uuid
    "column name"
    uv
}

"update columns of table \"buffgeom.attributes\""
enum geometry_attributes_update_column {
    "column name"
    index
    "column name"
    normal
    "column name"
    position
    "column name"
    type
    "column name"
    uuid
    "column name"
    uv
}

"unique or primary key constraints on table \"lht_ceiling.properties\""
enum lc_properties_constraint {
    "unique or primary key constraint on columns \"uuid\", \"id\""
    properties_id_uuid_key
    "unique or primary key constraint on columns \"type\", \"uuid\", \"id\", \"subtype\""
    properties_pkey
}

"select columns of table \"lht_ceiling.properties\""
enum lc_properties_select_column {
    "column name"
    id
    "column name"
    part
    "column name"
    stage
    "column name"
    status
    "column name"
    subtype
    "column name"
    type
    "column name"
    uuid
    "column name"
    zone
}

"update columns of table \"lht_ceiling.properties\""
enum lc_properties_update_column {
    "column name"
    id
    "column name"
    part
    "column name"
    stage
    "column name"
    status
    "column name"
    subtype
    "column name"
    type
    "column name"
    uuid
    "column name"
    zone
}

"column ordering options"
enum order_by {
    "in ascending order, nulls last"
    asc
    "in ascending order, nulls first"
    asc_nulls_first
    "in ascending order, nulls last"
    asc_nulls_last
    "in descending order, nulls first"
    desc
    "in descending order, nulls first"
    desc_nulls_first
    "in descending order, nulls last"
    desc_nulls_last
}

"unique or primary key constraints on table \"presets.colors\""
enum presets_colors_constraint {
    "unique or primary key constraint on columns \"decimal\""
    colors_decimal_key
    "unique or primary key constraint on columns \"hex\""
    colors_hex_key
    "unique or primary key constraint on columns \"id\""
    colors_id_key
    "unique or primary key constraint on columns \"id\", \"palette\""
    colors_pkey
}

"select columns of table \"presets.colors\""
enum presets_colors_select_column {
    "column name"
    b
    "column name"
    decimal
    "column name"
    g
    "column name"
    hex
    "column name"
    id
    "column name"
    name
    "column name"
    palette
    "column name"
    r
}

"update columns of table \"presets.colors\""
enum presets_colors_update_column {
    "column name"
    b
    "column name"
    decimal
    "column name"
    g
    "column name"
    hex
    "column name"
    id
    "column name"
    name
    "column name"
    palette
    "column name"
    r
}

"unique or primary key constraints on table \"projects.projects_hub\""
enum projects_projects_hub_constraint {
    "unique or primary key constraint on columns \"id\""
    projects_hub_pkey
}

"select columns of table \"projects.projects_hub\""
enum projects_projects_hub_select_column {
    "column name"
    id
    "column name"
    last_visited
    "column name"
    name
    "column name"
    thumb
}

"update columns of table \"projects.projects_hub\""
enum projects_projects_hub_update_column {
    "column name"
    id
    "column name"
    last_visited
    "column name"
    name
    "column name"
    thumb
}

"unique or primary key constraints on table \"projects.queries_hub\""
enum projects_queries_hub_constraint {
    "unique or primary key constraint on columns \"id\""
    queries_hub_pkey
}

"select columns of table \"projects.queries_hub\""
enum projects_queries_hub_select_column {
    "column name"
    body
    "column name"
    cr
    "column name"
    endpoint
    "column name"
    id
    "column name"
    name
    "column name"
    project_name
    "column name"
    tags
}

"update columns of table \"projects.queries_hub\""
enum projects_queries_hub_update_column {
    "column name"
    body
    "column name"
    cr
    "column name"
    endpoint
    "column name"
    id
    "column name"
    name
    "column name"
    project_name
    "column name"
    tags
}

"unique or primary key constraints on table \"tests.properties\""
enum properties_constraint {
    "unique or primary key constraint on columns \"index\""
    lht_tri_pnl_0_index_key
    "unique or primary key constraint on columns \"index\", \"uuid\""
    lht_tri_pnl_0_pkey
    "unique or primary key constraint on columns \"uuid\""
    lht_tri_pnl_0_uuid_key
}

"select columns of table \"tests.properties\""
enum properties_select_column {
    "column name"
    area
    "column name"
    index
    "column name"
    part
    "column name"
    stage
    "column name"
    status
    "column name"
    subtype
    "column name"
    type
    "column name"
    uuid
}

"update columns of table \"tests.properties\""
enum properties_update_column {
    "column name"
    area
    "column name"
    index
    "column name"
    part
    "column name"
    stage
    "column name"
    status
    "column name"
    subtype
    "column name"
    type
    "column name"
    uuid
}

"Scalar _Any"
scalar _Any

scalar jsonb

scalar name

scalar numeric

scalar timestamptz

scalar uuid

"Boolean expression to compare columns of type \"Boolean\". All fields are combined with logical 'AND'."
input Boolean_comparison_exp {
    _eq: Boolean
    _gt: Boolean
    _gte: Boolean
    _in: [Boolean!]
    _is_null: Boolean
    _lt: Boolean
    _lte: Boolean
    _neq: Boolean
    _nin: [Boolean!]
}

"Boolean expression to compare columns of type \"Int\". All fields are combined with logical 'AND'."
input Int_comparison_exp {
    _eq: Int
    _gt: Int
    _gte: Int
    _in: [Int!]
    _is_null: Boolean
    _lt: Int
    _lte: Int
    _neq: Int
    _nin: [Int!]
}

"Boolean expression to compare columns of type \"String\". All fields are combined with logical 'AND'."
input String_comparison_exp {
    _eq: String
    _gt: String
    _gte: String
    "does the column match the given case-insensitive pattern"
    _ilike: String
    _in: [String!]
    "does the column match the given POSIX regular expression, case insensitive"
    _iregex: String
    _is_null: Boolean
    "does the column match the given pattern"
    _like: String
    _lt: String
    _lte: String
    _neq: String
    "does the column NOT match the given case-insensitive pattern"
    _nilike: String
    _nin: [String!]
    "does the column NOT match the given POSIX regular expression, case insensitive"
    _niregex: String
    "does the column NOT match the given pattern"
    _nlike: String
    "does the column NOT match the given POSIX regular expression, case sensitive"
    _nregex: String
    "does the column NOT match the given SQL regular expression"
    _nsimilar: String
    "does the column match the given POSIX regular expression, case sensitive"
    _regex: String
    "does the column match the given SQL regular expression"
    _similar: String
}

"append existing jsonb value of filtered columns with new jsonb value"
input buffgeom_objects_append_input {
    children: jsonb
    matrix: jsonb
    userData: jsonb
}

"Boolean expression to filter rows from the table \"buffgeom.objects\". All fields are combined with a logical 'AND'."
input buffgeom_objects_bool_exp {
    _and: [buffgeom_objects_bool_exp!]
    _not: buffgeom_objects_bool_exp
    _or: [buffgeom_objects_bool_exp!]
    castShadow: Boolean_comparison_exp
    children: jsonb_comparison_exp
    geometry: uuid_comparison_exp
    layers: Int_comparison_exp
    material: uuid_comparison_exp
    matrix: jsonb_comparison_exp
    name: String_comparison_exp
    receiveShadow: Boolean_comparison_exp
    type: String_comparison_exp
    userData: jsonb_comparison_exp
    uuid: uuid_comparison_exp
}

"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
input buffgeom_objects_delete_at_path_input {
    children: [String!]
    matrix: [String!]
    userData: [String!]
}

"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
input buffgeom_objects_delete_elem_input {
    children: Int
    matrix: Int
    userData: Int
}

"delete key/value pair or string element. key/value pairs are matched based on their key value"
input buffgeom_objects_delete_key_input {
    children: String
    matrix: String
    userData: String
}

"input type for incrementing numeric columns in table \"buffgeom.objects\""
input buffgeom_objects_inc_input {
    layers: Int
}

"input type for inserting data into table \"buffgeom.objects\""
input buffgeom_objects_insert_input {
    castShadow: Boolean
    children: jsonb
    geometry: uuid
    layers: Int
    material: uuid
    matrix: jsonb
    name: String
    receiveShadow: Boolean
    type: String
    userData: jsonb
    uuid: uuid
}

"on_conflict condition type for table \"buffgeom.objects\""
input buffgeom_objects_on_conflict {
    constraint: buffgeom_objects_constraint!
    update_columns: [buffgeom_objects_update_column!]! = []
    where: buffgeom_objects_bool_exp
}

"Ordering options when selecting data from \"buffgeom.objects\"."
input buffgeom_objects_order_by {
    castShadow: order_by
    children: order_by
    geometry: order_by
    layers: order_by
    material: order_by
    matrix: order_by
    name: order_by
    receiveShadow: order_by
    type: order_by
    userData: order_by
    uuid: order_by
}

"primary key columns input for table: buffgeom.objects"
input buffgeom_objects_pk_columns_input {
    uuid: uuid!
}

"prepend existing jsonb value of filtered columns with new jsonb value"
input buffgeom_objects_prepend_input {
    children: jsonb
    matrix: jsonb
    userData: jsonb
}

"input type for updating data in table \"buffgeom.objects\""
input buffgeom_objects_set_input {
    castShadow: Boolean
    children: jsonb
    geometry: uuid
    layers: Int
    material: uuid
    matrix: jsonb
    name: String
    receiveShadow: Boolean
    type: String
    userData: jsonb
    uuid: uuid
}

"Streaming cursor of the table \"buffgeom_objects\""
input buffgeom_objects_stream_cursor_input {
    "Stream column input with initial value"
    initial_value: buffgeom_objects_stream_cursor_value_input!
    "cursor ordering"
    ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input buffgeom_objects_stream_cursor_value_input {
    castShadow: Boolean
    children: jsonb
    geometry: uuid
    layers: Int
    material: uuid
    matrix: jsonb
    name: String
    receiveShadow: Boolean
    type: String
    userData: jsonb
    uuid: uuid
}

input buffgeom_objects_updates {
    "append existing jsonb value of filtered columns with new jsonb value"
    _append: buffgeom_objects_append_input
    "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
    _delete_at_path: buffgeom_objects_delete_at_path_input
    "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
    _delete_elem: buffgeom_objects_delete_elem_input
    "delete key/value pair or string element. key/value pairs are matched based on their key value"
    _delete_key: buffgeom_objects_delete_key_input
    "increments the numeric columns with given value of the filtered values"
    _inc: buffgeom_objects_inc_input
    "prepend existing jsonb value of filtered columns with new jsonb value"
    _prepend: buffgeom_objects_prepend_input
    "sets the columns of the filtered rows to the given values"
    _set: buffgeom_objects_set_input
    "filter the rows which have to be updated"
    where: buffgeom_objects_bool_exp!
}

"append existing jsonb value of filtered columns with new jsonb value"
input geometry_attributes_append_input {
    index: jsonb
    normal: jsonb
    position: jsonb
    uv: jsonb
}

"Boolean expression to filter rows from the table \"buffgeom.attributes\". All fields are combined with a logical 'AND'."
input geometry_attributes_bool_exp {
    _and: [geometry_attributes_bool_exp!]
    _not: geometry_attributes_bool_exp
    _or: [geometry_attributes_bool_exp!]
    index: jsonb_comparison_exp
    normal: jsonb_comparison_exp
    position: jsonb_comparison_exp
    type: String_comparison_exp
    uuid: uuid_comparison_exp
    uv: jsonb_comparison_exp
}

"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
input geometry_attributes_delete_at_path_input {
    index: [String!]
    normal: [String!]
    position: [String!]
    uv: [String!]
}

"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
input geometry_attributes_delete_elem_input {
    index: Int
    normal: Int
    position: Int
    uv: Int
}

"delete key/value pair or string element. key/value pairs are matched based on their key value"
input geometry_attributes_delete_key_input {
    index: String
    normal: String
    position: String
    uv: String
}

"input type for inserting data into table \"buffgeom.attributes\""
input geometry_attributes_insert_input {
    index: jsonb
    normal: jsonb
    position: jsonb
    type: String
    uuid: uuid
    uv: jsonb
}

"on_conflict condition type for table \"buffgeom.attributes\""
input geometry_attributes_on_conflict {
    constraint: geometry_attributes_constraint!
    update_columns: [geometry_attributes_update_column!]! = []
    where: geometry_attributes_bool_exp
}

"Ordering options when selecting data from \"buffgeom.attributes\"."
input geometry_attributes_order_by {
    index: order_by
    normal: order_by
    position: order_by
    type: order_by
    uuid: order_by
    uv: order_by
}

"primary key columns input for table: buffgeom.attributes"
input geometry_attributes_pk_columns_input {
    uuid: uuid!
}

"prepend existing jsonb value of filtered columns with new jsonb value"
input geometry_attributes_prepend_input {
    index: jsonb
    normal: jsonb
    position: jsonb
    uv: jsonb
}

"input type for updating data in table \"buffgeom.attributes\""
input geometry_attributes_set_input {
    index: jsonb
    normal: jsonb
    position: jsonb
    type: String
    uuid: uuid
    uv: jsonb
}

"Streaming cursor of the table \"geometry_attributes\""
input geometry_attributes_stream_cursor_input {
    "Stream column input with initial value"
    initial_value: geometry_attributes_stream_cursor_value_input!
    "cursor ordering"
    ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input geometry_attributes_stream_cursor_value_input {
    index: jsonb
    normal: jsonb
    position: jsonb
    type: String
    uuid: uuid
    uv: jsonb
}

input geometry_attributes_updates {
    "append existing jsonb value of filtered columns with new jsonb value"
    _append: geometry_attributes_append_input
    "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
    _delete_at_path: geometry_attributes_delete_at_path_input
    "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
    _delete_elem: geometry_attributes_delete_elem_input
    "delete key/value pair or string element. key/value pairs are matched based on their key value"
    _delete_key: geometry_attributes_delete_key_input
    "prepend existing jsonb value of filtered columns with new jsonb value"
    _prepend: geometry_attributes_prepend_input
    "sets the columns of the filtered rows to the given values"
    _set: geometry_attributes_set_input
    "filter the rows which have to be updated"
    where: geometry_attributes_bool_exp!
}

input jsonb_cast_exp {
    String: String_comparison_exp
}

"Boolean expression to compare columns of type \"jsonb\". All fields are combined with logical 'AND'."
input jsonb_comparison_exp {
    _cast: jsonb_cast_exp
    "is the column contained in the given json value"
    _contained_in: jsonb
    "does the column contain the given json value at the top level"
    _contains: jsonb
    _eq: jsonb
    _gt: jsonb
    _gte: jsonb
    "does the string exist as a top-level key in the column"
    _has_key: String
    "do all of these strings exist as top-level keys in the column"
    _has_keys_all: [String!]
    "do any of these strings exist as top-level keys in the column"
    _has_keys_any: [String!]
    _in: [jsonb!]
    _is_null: Boolean
    _lt: jsonb
    _lte: jsonb
    _neq: jsonb
    _nin: [jsonb!]
}

"Boolean expression to filter rows from the table \"lht_ceiling.properties\". All fields are combined with a logical 'AND'."
input lc_properties_bool_exp {
    _and: [lc_properties_bool_exp!]
    _not: lc_properties_bool_exp
    _or: [lc_properties_bool_exp!]
    id: Int_comparison_exp
    part: String_comparison_exp
    stage: String_comparison_exp
    status: String_comparison_exp
    subtype: String_comparison_exp
    type: String_comparison_exp
    uuid: uuid_comparison_exp
    zone: String_comparison_exp
}

"input type for incrementing numeric columns in table \"lht_ceiling.properties\""
input lc_properties_inc_input {
    id: Int
}

"input type for inserting data into table \"lht_ceiling.properties\""
input lc_properties_insert_input {
    id: Int
    part: String
    stage: String
    status: String
    subtype: String
    type: String
    uuid: uuid
    zone: String
}

"on_conflict condition type for table \"lht_ceiling.properties\""
input lc_properties_on_conflict {
    constraint: lc_properties_constraint!
    update_columns: [lc_properties_update_column!]! = []
    where: lc_properties_bool_exp
}

"Ordering options when selecting data from \"lht_ceiling.properties\"."
input lc_properties_order_by {
    id: order_by
    part: order_by
    stage: order_by
    status: order_by
    subtype: order_by
    type: order_by
    uuid: order_by
    zone: order_by
}

"primary key columns input for table: lht_ceiling.properties"
input lc_properties_pk_columns_input {
    id: Int!
    subtype: String!
    type: String!
    uuid: uuid!
}

"input type for updating data in table \"lht_ceiling.properties\""
input lc_properties_set_input {
    id: Int
    part: String
    stage: String
    status: String
    subtype: String
    type: String
    uuid: uuid
    zone: String
}

"Streaming cursor of the table \"lc_properties\""
input lc_properties_stream_cursor_input {
    "Stream column input with initial value"
    initial_value: lc_properties_stream_cursor_value_input!
    "cursor ordering"
    ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input lc_properties_stream_cursor_value_input {
    id: Int
    part: String
    stage: String
    status: String
    subtype: String
    type: String
    uuid: uuid
    zone: String
}

input lc_properties_updates {
    "increments the numeric columns with given value of the filtered values"
    _inc: lc_properties_inc_input
    "sets the columns of the filtered rows to the given values"
    _set: lc_properties_set_input
    "filter the rows which have to be updated"
    where: lc_properties_bool_exp!
}

"Boolean expression to compare columns of type \"name\". All fields are combined with logical 'AND'."
input name_comparison_exp {
    _eq: name
    _gt: name
    _gte: name
    _in: [name!]
    _is_null: Boolean
    _lt: name
    _lte: name
    _neq: name
    _nin: [name!]
}

"Boolean expression to compare columns of type \"numeric\". All fields are combined with logical 'AND'."
input numeric_comparison_exp {
    _eq: numeric
    _gt: numeric
    _gte: numeric
    _in: [numeric!]
    _is_null: Boolean
    _lt: numeric
    _lte: numeric
    _neq: numeric
    _nin: [numeric!]
}

"Boolean expression to filter rows from the table \"presets.colors\". All fields are combined with a logical 'AND'."
input presets_colors_bool_exp {
    _and: [presets_colors_bool_exp!]
    _not: presets_colors_bool_exp
    _or: [presets_colors_bool_exp!]
    b: Int_comparison_exp
    decimal: Int_comparison_exp
    g: Int_comparison_exp
    hex: String_comparison_exp
    id: Int_comparison_exp
    name: name_comparison_exp
    palette: Int_comparison_exp
    r: Int_comparison_exp
}

"input type for incrementing numeric columns in table \"presets.colors\""
input presets_colors_inc_input {
    b: Int
    decimal: Int
    g: Int
    id: Int
    palette: Int
    r: Int
}

"input type for inserting data into table \"presets.colors\""
input presets_colors_insert_input {
    b: Int
    decimal: Int
    g: Int
    hex: String
    id: Int
    name: name
    palette: Int
    r: Int
}

"on_conflict condition type for table \"presets.colors\""
input presets_colors_on_conflict {
    constraint: presets_colors_constraint!
    update_columns: [presets_colors_update_column!]! = []
    where: presets_colors_bool_exp
}

"Ordering options when selecting data from \"presets.colors\"."
input presets_colors_order_by {
    b: order_by
    decimal: order_by
    g: order_by
    hex: order_by
    id: order_by
    name: order_by
    palette: order_by
    r: order_by
}

"primary key columns input for table: presets.colors"
input presets_colors_pk_columns_input {
    id: Int!
    palette: Int!
}

"input type for updating data in table \"presets.colors\""
input presets_colors_set_input {
    b: Int
    decimal: Int
    g: Int
    hex: String
    id: Int
    name: name
    palette: Int
    r: Int
}

"Streaming cursor of the table \"presets_colors\""
input presets_colors_stream_cursor_input {
    "Stream column input with initial value"
    initial_value: presets_colors_stream_cursor_value_input!
    "cursor ordering"
    ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input presets_colors_stream_cursor_value_input {
    b: Int
    decimal: Int
    g: Int
    hex: String
    id: Int
    name: name
    palette: Int
    r: Int
}

input presets_colors_updates {
    "increments the numeric columns with given value of the filtered values"
    _inc: presets_colors_inc_input
    "sets the columns of the filtered rows to the given values"
    _set: presets_colors_set_input
    "filter the rows which have to be updated"
    where: presets_colors_bool_exp!
}

"Boolean expression to filter rows from the table \"projects.projects_hub\". All fields are combined with a logical 'AND'."
input projects_projects_hub_bool_exp {
    _and: [projects_projects_hub_bool_exp!]
    _not: projects_projects_hub_bool_exp
    _or: [projects_projects_hub_bool_exp!]
    id: uuid_comparison_exp
    last_visited: timestamptz_comparison_exp
    name: String_comparison_exp
    thumb: String_comparison_exp
}

"input type for inserting data into table \"projects.projects_hub\""
input projects_projects_hub_insert_input {
    id: uuid
    last_visited: timestamptz
    name: String
    thumb: String
}

"on_conflict condition type for table \"projects.projects_hub\""
input projects_projects_hub_on_conflict {
    constraint: projects_projects_hub_constraint!
    update_columns: [projects_projects_hub_update_column!]! = []
    where: projects_projects_hub_bool_exp
}

"Ordering options when selecting data from \"projects.projects_hub\"."
input projects_projects_hub_order_by {
    id: order_by
    last_visited: order_by
    name: order_by
    thumb: order_by
}

"primary key columns input for table: projects.projects_hub"
input projects_projects_hub_pk_columns_input {
    id: uuid!
}

"input type for updating data in table \"projects.projects_hub\""
input projects_projects_hub_set_input {
    id: uuid
    last_visited: timestamptz
    name: String
    thumb: String
}

"Streaming cursor of the table \"projects_projects_hub\""
input projects_projects_hub_stream_cursor_input {
    "Stream column input with initial value"
    initial_value: projects_projects_hub_stream_cursor_value_input!
    "cursor ordering"
    ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input projects_projects_hub_stream_cursor_value_input {
    id: uuid
    last_visited: timestamptz
    name: String
    thumb: String
}

input projects_projects_hub_updates {
    "sets the columns of the filtered rows to the given values"
    _set: projects_projects_hub_set_input
    "filter the rows which have to be updated"
    where: projects_projects_hub_bool_exp!
}

"append existing jsonb value of filtered columns with new jsonb value"
input projects_queries_hub_append_input {
    body: jsonb
    tags: jsonb
}

"Boolean expression to filter rows from the table \"projects.queries_hub\". All fields are combined with a logical 'AND'."
input projects_queries_hub_bool_exp {
    _and: [projects_queries_hub_bool_exp!]
    _not: projects_queries_hub_bool_exp
    _or: [projects_queries_hub_bool_exp!]
    body: jsonb_comparison_exp
    cr: timestamptz_comparison_exp
    endpoint: String_comparison_exp
    id: uuid_comparison_exp
    name: String_comparison_exp
    project_name: String_comparison_exp
    tags: jsonb_comparison_exp
}

"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
input projects_queries_hub_delete_at_path_input {
    body: [String!]
    tags: [String!]
}

"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
input projects_queries_hub_delete_elem_input {
    body: Int
    tags: Int
}

"delete key/value pair or string element. key/value pairs are matched based on their key value"
input projects_queries_hub_delete_key_input {
    body: String
    tags: String
}

"input type for inserting data into table \"projects.queries_hub\""
input projects_queries_hub_insert_input {
    body: jsonb
    cr: timestamptz
    endpoint: String
    id: uuid
    name: String
    project_name: String
    tags: jsonb
}

"on_conflict condition type for table \"projects.queries_hub\""
input projects_queries_hub_on_conflict {
    constraint: projects_queries_hub_constraint!
    update_columns: [projects_queries_hub_update_column!]! = []
    where: projects_queries_hub_bool_exp
}

"Ordering options when selecting data from \"projects.queries_hub\"."
input projects_queries_hub_order_by {
    body: order_by
    cr: order_by
    endpoint: order_by
    id: order_by
    name: order_by
    project_name: order_by
    tags: order_by
}

"primary key columns input for table: projects.queries_hub"
input projects_queries_hub_pk_columns_input {
    id: uuid!
}

"prepend existing jsonb value of filtered columns with new jsonb value"
input projects_queries_hub_prepend_input {
    body: jsonb
    tags: jsonb
}

"input type for updating data in table \"projects.queries_hub\""
input projects_queries_hub_set_input {
    body: jsonb
    cr: timestamptz
    endpoint: String
    id: uuid
    name: String
    project_name: String
    tags: jsonb
}

"Streaming cursor of the table \"projects_queries_hub\""
input projects_queries_hub_stream_cursor_input {
    "Stream column input with initial value"
    initial_value: projects_queries_hub_stream_cursor_value_input!
    "cursor ordering"
    ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input projects_queries_hub_stream_cursor_value_input {
    body: jsonb
    cr: timestamptz
    endpoint: String
    id: uuid
    name: String
    project_name: String
    tags: jsonb
}

input projects_queries_hub_updates {
    "append existing jsonb value of filtered columns with new jsonb value"
    _append: projects_queries_hub_append_input
    "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
    _delete_at_path: projects_queries_hub_delete_at_path_input
    "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
    _delete_elem: projects_queries_hub_delete_elem_input
    "delete key/value pair or string element. key/value pairs are matched based on their key value"
    _delete_key: projects_queries_hub_delete_key_input
    "prepend existing jsonb value of filtered columns with new jsonb value"
    _prepend: projects_queries_hub_prepend_input
    "sets the columns of the filtered rows to the given values"
    _set: projects_queries_hub_set_input
    "filter the rows which have to be updated"
    where: projects_queries_hub_bool_exp!
}

"Boolean expression to filter rows from the table \"tests.properties\". All fields are combined with a logical 'AND'."
input properties_bool_exp {
    _and: [properties_bool_exp!]
    _not: properties_bool_exp
    _or: [properties_bool_exp!]
    area: numeric_comparison_exp
    index: Int_comparison_exp
    part: String_comparison_exp
    stage: String_comparison_exp
    status: String_comparison_exp
    subtype: Int_comparison_exp
    type: String_comparison_exp
    uuid: uuid_comparison_exp
}

"input type for incrementing numeric columns in table \"tests.properties\""
input properties_inc_input {
    area: numeric
    index: Int
    subtype: Int
}

"input type for inserting data into table \"tests.properties\""
input properties_insert_input {
    area: numeric
    index: Int
    part: String
    stage: String
    status: String
    subtype: Int
    type: String
    uuid: uuid
}

"on_conflict condition type for table \"tests.properties\""
input properties_on_conflict {
    constraint: properties_constraint!
    update_columns: [properties_update_column!]! = []
    where: properties_bool_exp
}

"Ordering options when selecting data from \"tests.properties\"."
input properties_order_by {
    area: order_by
    index: order_by
    part: order_by
    stage: order_by
    status: order_by
    subtype: order_by
    type: order_by
    uuid: order_by
}

"primary key columns input for table: tests.properties"
input properties_pk_columns_input {
    index: Int!
    uuid: uuid!
}

"input type for updating data in table \"tests.properties\""
input properties_set_input {
    area: numeric
    index: Int
    part: String
    stage: String
    status: String
    subtype: Int
    type: String
    uuid: uuid
}

"Streaming cursor of the table \"properties\""
input properties_stream_cursor_input {
    "Stream column input with initial value"
    initial_value: properties_stream_cursor_value_input!
    "cursor ordering"
    ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input properties_stream_cursor_value_input {
    area: numeric
    index: Int
    part: String
    stage: String
    status: String
    subtype: Int
    type: String
    uuid: uuid
}

input properties_updates {
    "increments the numeric columns with given value of the filtered values"
    _inc: properties_inc_input
    "sets the columns of the filtered rows to the given values"
    _set: properties_set_input
    "filter the rows which have to be updated"
    where: properties_bool_exp!
}

"Boolean expression to compare columns of type \"timestamptz\". All fields are combined with logical 'AND'."
input timestamptz_comparison_exp {
    _eq: timestamptz
    _gt: timestamptz
    _gte: timestamptz
    _in: [timestamptz!]
    _is_null: Boolean
    _lt: timestamptz
    _lte: timestamptz
    _neq: timestamptz
    _nin: [timestamptz!]
}

"Boolean expression to compare columns of type \"uuid\". All fields are combined with logical 'AND'."
input uuid_comparison_exp {
    _eq: uuid
    _gt: uuid
    _gte: uuid
    _in: [uuid!]
    _is_null: Boolean
    _lt: uuid
    _lte: uuid
    _neq: uuid
    _nin: [uuid!]
}
